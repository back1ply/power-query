Topic,Page,Page Content
Introduction,https://learn.microsoft.com/en-us/powerquery-m/m-spec-introduction,"Introduction
										
											Article07/21/2023
															
															2 contributors
														
										

	
		
			
		
		Feedback
	
 
		In this article
		
			
					
						Overview
					
				
					
						Expressions and values
					
				
					
						Evaluation
					
				
					
						Functions
					
				
					
						Library
					
				
					
						Operators
					
				
					
						Metadata
					
				
					
						Let expression
					
				
					
						If expression
					
				
					
						Errors
					
				
		
	 
		
			Show 6 more
			
		
	 Overview
Microsoft Power Query provides a powerful ""get data"" experience that encompasses many features. A core capability of Power Query is to filter and combine, that is, to ""mash-up"" data from one or more of a rich collection of supported data sources. Any such data mashup is expressed using the Power Query formula language (informally known as ""M""). Power Query embeds M documents in a wide range of Microsoft products, including Excel, Power BI, Analysis Services, and Dataverse, to enable repeatable mashup of data.
This document provides the specification for M. After a brief introduction that aims at building some first intuition and familiarity with the language, the document covers the language precisely in several progressive steps:

The lexical structure defines the set of texts that are lexically valid.

Values, expressions, environments and variables, identifiers, and the evaluation model form the language's basic concepts.

The detailed specification of values, both primitive and structured, defines the target domain of the language.

Values have types, themselves a special kind of value, that both characterize the fundamental kinds of values and carry additional metadata that is specific to the shapes of structured values.

The set of operators in M defines what kinds of expressions can be formed.

Functions, another kind of special values, provide the foundation for a rich standard library for M and allow for the addition of new abstractions.

Errors can occur when applying operators or functions during expression evaluation. While errors aren't values, there are ways to handle errors that map errors back to values.

Let expressions allow for the introduction of auxiliary definitions used to build up complex expressions in smaller steps.

If expressions support conditional evaluation.

Sections provide a simple modularity mechanism. (Sections aren't yet leveraged by Power Query.)

Finally, a consolidated grammar collects the grammar fragments from all other sections of this document into a single complete definition.


For computer language theorists: the formula language specified in this document is a mostly pure, higher-order, dynamically typed, partially lazy functional language.
Expressions and values
The central construct in M is the expression. An expression can be evaluated (computed), yielding a single value.
Although many values can be written literally as an expression, a value isn't an expression. For example, the expression 1 evaluates to the value 1; the expressions 1+1 evaluates to the value 2. This distinction is subtle, but important. Expressions are recipes for evaluation; values are the results of evaluation.
The following examples illustrate the different kinds of values available in M. As a convention, a value is written using the literal form in which they would appear in an expression that evaluates to just that value. (Note that the // indicates the start of a comment which continues to the end of the line.)

A primitive value is single-part value, such as a number, logical, text, or null. A null value can be used to indicate the absence of any data.
123                  // A number
true                 // A logical
""abc""                // A text
null                 // null value


A list value is an ordered sequence of values. M supports infinite lists, but if written as a literal, lists have a fixed length. The curly brace characters { and } denote the beginning and end of a list.
{123, true, ""A""}     // list containing a number, a logical, and 
                      //     a text 
{1, 2, 3}            // list of three numbers 


A record is a set of fields. A field is a name/value pair where the name is a text value that's unique within the field's record. The literal syntax for record values allows the names to be written without quotes, a form also referred to as identifiers. The following shows a record containing three fields named ""A"", ""B"", and ""C"", which have values 1, 2, and 3.
[ 
      A = 1,  
      B = 2,  
      C = 3 
]


A table is a set of values organized into columns (which are identified by name), and rows. There's no literal syntax for creating a table, but there are several standard functions that can be used to create tables from lists or records.
For example:
#table( {""A"", ""B""}, { {1, 2}, {3, 4} } ) 

This creates a table of the following shape:





A function is a value that, when invoked with arguments, produces a new value. A function is written by listing the function's parameters in parentheses, followed by the goes-to symbol =>, followed by the expression defining the function. That expression typically refers to the parameters (by name).
(x, y) => (x + y) / 2`



Evaluation
The evaluation model of the M language is modeled after the evaluation model commonly found in spreadsheets, where the order of calculation can be determined based on dependencies between the formulas in the cells.
If you've written formulas in a spreadsheet such as Excel, you may recognize the formulas on the left result in the values on the right when calculated:




In M, parts of an expression can reference other parts of the expression by name, and the evaluation process automatically determines the order in which referenced expressions are calculated.
You can use a record to produce an expression that's equivalent to the previous spreadsheet example. When initializing the value of a field, you can refer to other fields within the record by using the name of the field, as follows:
[  
    A1 = A2 * 2,  
    A2 = A3 + 1,  
    A3 = 1  
]

The above expression is equivalent to the following (in that both evaluate to equal values):
[  
    A1 = 4,  
    A2 = 2,  
    A3 = 1  
]

Records can be contained within, or nest, within other records. You can use the lookup operator ([]) to access the fields of a record by name. For example, the following record has a field named Sales containing a record, and a field named Total that accesses the FirstHalf and SecondHalf fields of the Sales record:
[  
    Sales = [ FirstHalf = 1000, SecondHalf = 1100 ], 
    Total = Sales[FirstHalf] + Sales[SecondHalf] 
]

The above expression is equivalent to the following when it is evaluated:
[  
    Sales = [ FirstHalf = 1000, SecondHalf = 1100 ], 
    Total = 2100 
]

Records can also be contained within lists. You can use the positional index operator ({}) to access an item in a list by its numeric index. The values within a list are referred to using a zero-based index from the beginning of the list. For example, the indexes 0 and 1 are used to reference the first and second items in the list below:
[ 
    Sales =  
        {  
            [  
                Year = 2007,  
                FirstHalf = 1000,  
                SecondHalf = 1100, 
                Total = FirstHalf + SecondHalf // 2100 
            ], 
            [  
                Year = 2008,  
                FirstHalf = 1200,  
                SecondHalf = 1300, 
                Total = FirstHalf + SecondHalf // 2500 
            ]  
        }, 
    TotalSales = Sales{0}[Total] + Sales{1}[Total] // 4600 
]

List and record member expressions (as well as let expressions) are evaluated using lazy evaluation, which means that they are evaluated only as needed. All other expressions are evaluated using eager evaluation, which means that they are evaluated immediately when encountered during the evaluation process. A good way to think about this is to remember that evaluating a list or record expression returns a list or record value that itself remembers how its list items or record fields need to be computed, when requested (by lookup or index operators).
Functions
In M, a function is a mapping from a set of input values to a single output value. A function is written by first naming the required set of input values (the parameters to the function) and then providing an expression that computes the result of the function using those input values (the body of the function) following the goes-to (=>) symbol. For example:
(x) => x + 1                    // function that adds one to a value 
(x, y) =>  x + y                // function that adds two values

A function is a value just like a number or a text value. The following example shows a function that is the value of an Add field which is then invoked, or executed, from several other fields. When a function is invoked, a set of values are specified that are logically substituted for the required set of input values within the function body expression.
[ 
    Add = (x, y) => x + y,
    OnePlusOne = Add(1, 1),     // 2 
    OnePlusTwo = Add(1, 2)      // 3
]

Library
M includes a common set of definitions available for use from an expression called the standard library, or just library for short. These definitions consist of a set of named values. The names of values provided by a library are available for use within an expression without having been defined explicitly by the expression. For example:
Number.E                        // Euler's number e (2.7182...) 
Text.PositionOf(""Hello"", ""ll"")  // 2

Operators
M includes a set of operators that can be used in expressions. Operators are applied to operands to form symbolic expressions. For example, in the expression 1 + 2 the numbers 1 and 2 are operands and the operator is the addition operator (+).
The meaning of an operator can vary depending on what kind of values its operands are. For example, the plus operator can be used with other kinds of values besides numbers:
1 + 2                   // numeric addition: 3 
#time(12,23,0) + #duration(0,0,2,0) 
                        // time arithmetic: #time(12,25,0)

Another example of an operator with operand-depending meaning is the combination operator (&):
""A"" & ""BC""              // text concatenation: ""ABC"" 
{1} & {2, 3}            // list concatenation: {1, 2, 3} 
[ a = 1 ] & [ b = 2 ]   // record merge: [ a = 1, b = 2 ]

Note that some operators don't support all combinations of values. For example:
1 + ""2""  // error: adding number and text isn't supported

Expressions that, when evaluated, encounter undefined operator conditions evaluate to errors.
Metadata
Metadata is information about a value that's associated with a value. Metadata is represented as a record value, called a metadata record. The fields of a metadata record can be used to store the metadata for a value.
Every value has a metadata record. If the value of the metadata record hasn't been specified, then the metadata record is empty (has no fields).
Metadata records provide a way to associate additional information with any kind of value in an unobtrusive way. Associating a metadata record with a value doesn't change the value or its behavior.
A metadata record value y is associated with an existing value x using the syntax x meta y. For example, the following code associates a metadata record with Rating and Tags fields with the text value ""Mozart"":
""Mozart"" meta [ Rating = 5, Tags = {""Classical""} ]

For values that already carry a non-empty metadata record, the result of applying meta is that of computing the record merge of the existing and the new metadata record. For example, the following two expressions are equivalent to each other and to the previous expression:
(""Mozart"" meta [ Rating = 5 ]) meta [ Tags = {""Classical""} ] 
""Mozart"" meta ([ Rating = 5 ] & [ Tags = {""Classical""} ])

A metadata record can be accessed for a given value using the Value.Metadata function. In the following example, the expression in the ComposerRating field accesses the metadata record of the value in the Composer field, and then accesses the Rating field of the metadata record.
[ 
    Composer = ""Mozart"" meta [ Rating = 5, Tags = {""Classical""} ], 
    ComposerRating = Value.Metadata(Composer)[Rating] // 5
]

Let expression
Many of the examples shown so far have included all the literal values of the expression in the result of the expression. The let expression allows a set of values to be computed, assigned names, and then used in a subsequent expression that follows the in. For example, in our sales data example, you could do:
let 
    Sales2007 =  
        [  
            Year = 2007,  
            FirstHalf = 1000,  
            SecondHalf = 1100, 
            Total = FirstHalf + SecondHalf // 2100 
        ], 
    Sales2008 =  
        [  
            Year = 2008,  
            FirstHalf = 1200,  
            SecondHalf = 1300, 
            Total = FirstHalf + SecondHalf // 2500 
        ] 
  in Sales2007[Total] + Sales2008[Total] // 4600

The result of the above expression is a number value (4600) that's computed from the values bound to the names Sales2007 and Sales2008.
If expression
The if expression selects between two expressions based on a logical condition. For example:
if 2 > 1 then
    2 + 2
else  
    1 + 1

The first expression (2 + 2) is selected if the logical expression (2 > 1) is true, and the second expression (1 + 1) is selected if it's false. The selected expression (in this case 2 + 2) is evaluated and becomes the result of the if expression (4).
Errors
An error is an indication that the process of evaluating an expression couldn't produce a value.
Errors are raised by operators and functions encountering error conditions or by using the error expression. Errors are handled using the try expression. When an error is raised, a value is specified that can be used to indicate why the error occurred.
let Sales = 
    [ 
        Revenue = 2000, 
        Units = 1000, 
        UnitPrice = if Units = 0 then error ""No Units""
                    else Revenue / Units 
    ], 
    UnitPrice = try Number.ToText(Sales[UnitPrice])
in ""Unit Price: "" & 
    (if UnitPrice[HasError] then UnitPrice[Error][Message]
    else UnitPrice[Value])

The above example accesses the Sales[UnitPrice] field and formats the value producing the result:
""Unit Price: 2""

If the Units field had been zero, then the UnitPrice field would have raised an error, which would have been handled by the try. The resulting value would then have been:
""No Units""

A try expression converts proper values and errors into a record value that indicates whether the try expression handled an error, or not, and either the proper value or the error record it extracted when handling the error. For example, consider the following expression that raises an error and then handles it right away:
try error ""negative unit count""

This expression evaluates to the following nested record value, explaining the [HasError], [Error], and [Message] field lookups in the previous unit-price example.
[ 
    HasError = true, 
    Error = 
        [ 
            Reason = ""Expression.Error"", 
            Message = ""negative unit count"", 
            Detail = null 
        ] 
]

A common case is to replace errors with default values. The try expression can be used with an optional otherwise clause to achieve just that in a compact form:
try error ""negative unit count"" otherwise 42 
// 42"
Lexical Structure,https://learn.microsoft.com/en-us/powerquery-m/m-spec-lexical-structure,"Lexical Structure
										
											Article08/09/2022
															
															2 contributors
														
										

	
		
			
		
		Feedback
	
 
		In this article
		
			
					
						Documents
					
				
					
						Grammar conventions
					
				
					
						Lexical Analysis
					
				
					
						Whitespace
					
				
					
						Comments
					
				
					
						Tokens
					
				
		
	 
		
			Show 2 more
			
		
	 Documents
An M document is an ordered sequence of Unicode characters. M allows different classes of Unicode characters in different parts of an M document. For information on Unicode character classes, see The Unicode Standard, Version 3.0, section 4.5.
A document either consists of exactly one expression or of groups of definitions organized into sections. Sections are described in detail in Chapter 10. Conceptually speaking, the following steps are used to read an expression from a document:

The document is decoded according to its character encoding scheme into a sequence of Unicode characters.

Lexical analysis is performed, thereby translating the stream of Unicode characters into a stream of tokens. The remaining subsections of this section cover lexical analysis.

Syntactic analysis is performed, thereby translating the stream of tokens into a form that can be evaluated. This process is covered in subsequent sections.


Grammar conventions
The lexical and syntactic grammars are presented using grammar productions. Each grammar production defines a non-terminal symbol and the possible expansions of that nonterminal symbol into sequences of non-terminal or terminal symbols. In grammar productions, non-terminal+ symbols are shown in italic type, and terminal symbols are shown in a fixed-width font.
The first line of a grammar production is the name of the non-terminal symbol being defined, followed by a colon. Each successive indented line contains a possible expansion of the nonterminal given as a sequence of non-terminal or terminal symbols. For example, the production:
if-expression:
      if if-condition then true-expression  else  false-expression
defines an if-expression to consist of the token if,  followed by an if-condition, followed by the token then, followed by a true-expression, followed by the token else, followed by a false-expression.
When there is more than one possible expansion of a non-terminal symbol, the alternatives are listed on separate lines. For example, the production:
variable-list:
      variable
      variable-list , variable
defines a variable-list to either consist of a variable or consist of a variable-list followed by a variable. In other words, the definition is recursive and specifies that a variable list consists of one or more variables, separated by commas.
A subscripted suffix ""opt"" is used to indicate an optional symbol. The production:
field-specification:
      optionalopt field-name = field-type
is shorthand for:
field-specification:
      field-name = field-type
      optional field-name = field-type
and defines a field-specification to optionally begin with the terminal symbol optional followed by a field-name, the terminal symbol =, and a field-type.
Alternatives are normally listed on separate lines, though in cases where there are many alternatives, the phrase ""one of"" may precede a list of expansions given on a single line. This is simply shorthand for listing each of the alternatives on a separate line. For example, the production:
decimal-digit:  one of
      0  1  2  3  4  5  6  7  8  9
is shorthand for:
decimal-digit: 
      0
      1
      2
      3
      4
      5
      6
      7
      8
      9
Lexical Analysis
The lexical-unit production defines the lexical grammar for an M document. Every valid M document conforms to this grammar.
lexical-unit:
      lexical-elementsopt
lexical-elements:
      lexical-element
      lexical-element
      lexical-elements
lexical-element:
      whitespace
      token comment
At the lexical level, an M document consists of a stream of whitespace, comment, and token elements. Each of these productions is covered in the following sections. Only token elements are significant in the syntactic grammar.
Whitespace
Whitespace is used to separate comments and tokens within an M document. Whitespace includes the space character (which is part of Unicode class Zs), as well as horizontal and vertical tab, form feed, and newline character sequences. Newline character sequences include carriage return, line feed, carriage return followed by line feed, next line, and paragraph separator characters.
whitespace:
      Any character with Unicode class Zs
      Horizontal tab character (U+0009)
      Vertical tab character (U+000B)
      Form feed character (U+000C)
      Carriage return character (U+000D) followed by line feed character (U+000A)
      new-line-character
new-line-character:
      Carriage return character (U+000D)
      Line feed character (U+000A)
      Next line character (U+0085)
      Line separator character (U+2028)
      Paragraph separator character (U+2029)
For compatibility with source code editing tools that add end-of-file markers, and to enable a document to be viewed as a sequence of properly terminated lines, the following transformations are applied, in order, to an M document:

If the last character of the document is a Control-Z character (U+001A), this character is deleted.

A carriage-return character (U+000D) is added to the end of the document if that document is non-empty and if the last character of the document is not a carriage return (U+000D), a line feed (U+000A), a line separator (U+2028), or a paragraph separator (U+2029).


Comments
Two forms of comments are supported: single-line comments and delimited comments. Single-line comments start with the characters // and extend to the end of the source line. Delimited comments start with the characters /* and end with the characters */.
Delimited comments may span multiple lines.
comment:
      single-line-comment
      delimited-comment
single-line-comment:
      // single-line-comment-charactersopt
single-line-comment-characters:
      single-line-comment-character single-line-comment-charactersopt
single-line-comment-character:
      Any Unicode character except a new-line-character
delimited-comment:
      /* delimited-comment-textopt  asterisks  /
delimited-comment-text:
      delimited-comment-section delimited-comment-textopt
delimited-comment-section:
      /
      asterisksopt  not-slash-or-asterisk
asterisks:
      * asterisksopt
not-slash-or-asterisk:
      Any Unicode character except * or /
Comments do not nest. The character sequences /* and */ have no special meaning within a single-line comment, and the character sequences // and /* have no special meaning within a delimited comment.
Comments are not processed within text literals. The example
/* Hello, world 
*/ 
    ""Hello, world""

includes a delimited comment.
The example
// Hello, world 
// 
""Hello, world"" // This is an example of a text literal

shows several single-line comments.
Tokens
A token is an identifier, keyword, literal, operator, or punctuator. Whitespace and comments are used to separate tokens, but are not considered tokens.
token:
      identifier
      keyword
      literal
      operator-or-punctuator
Character Escape Sequences
M text values can contain arbitrary Unicode characters. Text literals, however, are limited to graphic characters and require the use of escape sequences for non-graphic characters. For example, to include a carriage-return, linefeed, or tab character in a text literal, the #(cr), #(lf), and #(tab) escape sequences can be used, respectively. To embed the escapesequence start characters #( in a text literal, the # itself needs to be escaped:
#(#)(

Escape sequences can also contain short (four hex digits) or long (eight hex digits) Unicode code-point values. The following three escape sequences are therefore equivalent:
#(000D)     // short Unicode hexadecimal value 
#(0000000D) // long Unicode hexadecimal value 
#(cr)       // compact escape shorthand for carriage return

Multiple escape codes can be included in a single escape sequence, separated by commas; the following two sequences are thus equivalent:
#(cr,lf) 
#(cr)#(lf)

The following describes the standard mechanism of character escaping in an M document.
character-escape-sequence:
      #(  escape-sequence-list  ) escape-sequence-list:
      single-escape-sequence
      single-escape-sequence  ,  escape-sequence-list
single-escape-sequence:
      long-unicode-escape-sequence
      short-unicode-escape-sequence
      control-character-escape-sequence
      escape-escape
long-unicode-escape-sequence:
      hex-digit  hex-digit  hex-digit  hex-digit  hex-digit  hex-digit  hex-digit  hex-digit
short-unicode-escape-sequence:
      hex-digit  hex-digit  hex-digit  hex-digit
control-character-escape-sequence:
      control-character
control-character:
      cr
      lf
      tab
escape-escape:
      #
Literals
A literal is a source code representation of a value.
literal:
      logical-literal
      number-literal
      text-literal
      null-literal
      verbatim-literal
Null literals
The null literal is used to write the null value. The null value represents an absent value.
null-literal:
      null
Logical literals
A logical literal is used to write the values true and false and produces a logical value.
logical-literal:
      true
      false
Number literals
A number literal is used to write a numeric value and produces a number value.
number-literal:
      decimal-number-literal
      hexadecimal-number-literal
decimal-number-literal:
      decimal-digits  .  decimal-digits  exponent-partopt
      .  decimal-digits  exponent-partopt
      decimal-digits  exponent-partopt
decimal-digits:
      decimal-digit decimal-digitsopt
decimal-digit:  one of
      0  1  2  3  4  5  6  7  8  9
exponent-part:
      e signopt  decimal-digits
      E signopt  decimal-digits sign: one of
      +  -
hexadecimal-number-literal:
      0x hex-digits
      0X hex-digits
hex-digits:
      hex-digit hex-digitsopt
hex-digit:  one of
      0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  a  b  c  d e  f
A number can be specified in hexadecimal format by preceding the hex-digits with the characters 0x. For example:
0xff // 255

Note that if a decimal point is included in a number literal, then it must have at least one digit following it. For example, 1.3 is a number literal but 1. and 1.e3 are not.
Text literals
A text literal is used to write a sequence of Unicode characters and produces a text value.
text-literal:
      ""  text-literal-charactersopt  ""
text-literal-characters:
      text-literal-character text-literal-charactersopt
text-literal-character:
      single-text-character
      character-escape-sequence
      double-quote-escape-sequence
single-text-character:
      Any character except "" (U+0022) or # (U+0023) followed by ( (U+0028)
double-quote-escape-sequence:
      """" (U+0022, U+0022)
To include quotes in a text value, the quote mark is repeated, as follows:
""The """"quoted"""" text"" // The ""quoted"" text

The character-escape-sequence production can be used to write characters in text values without having to directly encode them as Unicode characters in the document. For example, a carriage return and line feed can be written in a text value as:
""Hello world#(cr,lf)""

Verbatim literals
A verbatim literal is used to store a sequence of Unicode characters that were entered by a user as code, but which cannot be correctly parsed as code. At runtime, it produces an error value.
verbatim-literal:
      #!"" text-literal-charactersopt ""
Identifiers
An identifier is a name used to refer to a value. Identifiers can either be regular identifiers or quoted identifiers.
identifier:
      regular-identifier
      quoted-identifier
regular-identifier:
      available-identifier
      available-identifier  dot-character  regular-identifier
available-identifier:
      A keyword-or-identifier that is not a keyword
keyword-or-identifier:
      identifier-start-character  identifier-part-charactersopt
identifier-start-character:
      letter-character
      underscore-character
identifier-part-characters:
      identifier-part-character  identifier-part-charactersopt
identifier-part-character:
      letter-character
      decimal-digit-character
      underscore-character
      connecting-character
      combining-character
      formatting-character
dot-character:
      .  (U+002E)
underscore-character:
      _  (U+005F)
letter-character:
      A Unicode character of classes Lu, Ll, Lt, Lm, Lo, or Nl
combining-character:
      A Unicode character of classes Mn or Mc
decimal-digit-character:
      A Unicode character of the class Nd
connecting-character:
      A Unicode character of the class Pc
formatting-character:
      A Unicode character of the class Cf
A quoted-identifier can be used to allow any sequence of zero or more Unicode characters to be used as an identifier, including keywords, whitespace, comments, operators and punctuators.
quoted-identifier:
      #""   text-literal-charactersopt   ""
Note that escape sequences and double-quotes to escape quotes can be used in a quoted identifier, just as in a text-literal.
The following example uses identifier quoting for names containing a space character:
[ 
    #""1998 Sales"" = 1000, 
    #""1999 Sales"" = 1100, 
    #""Total Sales"" = #""1998 Sales"" + #""1999 Sales""
]

The following example uses identifier quoting to include the + operator in an identifier:
[ 
    #""A + B"" = A + B, 
    A = 1, 
    B = 2 
]

Generalized Identifiers
There are two places in M where no ambiguities are introduced by identifiers that contain blanks or that are otherwise keywords or number literals. These places are the names of record fields in a record literal and in a field access operator ([ ]) There, M allows such identifiers without having to use quoted identifiers.
[ 
    Data = [ Base Line = 100, Rate = 1.8 ], 
    Progression = Data[Base Line] * Data[Rate]
]

The identifiers used to name and access fields are referred to as generalized identifiers and defined as follows:
generalized-identifier:
      generalized-identifier-part
      generalized-identifier separated only by blanks (U+0020) generalized-identifier-part
generalized-identifier-part:
      generalized-identifier-segment
      decimal-digit-character generalized-identifier-segment
generalized-identifier-segment:
      keyword-or-identifier
      keyword-or-identifier  dot-character  keyword-or-identifier
Keywords
A keyword is an identifier-like sequence of characters that is reserved, and cannot be used as an identifier except when using the identifier-quoting mechanism or where a generalized identifier is allowed.
keyword: one of
       and as each else error false if in is let meta not null or otherwise
       section shared then true try type #binary #date #datetime
       #datetimezone #duration #infinity #nan #sections #shared #table #time
Operators and punctuators
There are several kinds of operators and punctuators. Operators are used in expressions to describe operations involving one or more operands. For example, the expression a + b uses the + operator to add the two operands a and b. Punctuators are for grouping and separating.
operator-or-punctuator:  one of
      , ; = < <= > >= <> + - * / & ( ) [ ] { } @ ! ? ?? => .. ..."
Basic Concepts,https://learn.microsoft.com/en-us/powerquery-m/m-spec-basic-concepts,"Basic concepts
										
											Article08/23/2023
															
															3 contributors
														
										

	
		
			
		
		Feedback
	
 
		In this article
		
			
					
						Values
					
				
					
						Expressions
					
				
					
						Environments and variables
					
				
					
						Order of evaluation
					
				
					
						Side effects
					
				
					
						Immutability
					
				
		
	 
		
			Show 2 more
			
		
	 This section discusses basic concepts that appear throughout the subsequent sections.
Values
A single piece of data is called a value. Broadly speaking, there are two general categories of values: primitive values, which are atomic, and structured values, which are constructed out of primitive values and other structured values. For example, the values
1 
true
3.14159 
""abc""

are primitive in that they are not made up of other values. On the other hand, the values
{1, 2, 3} 
[ A = {1}, B = {2}, C = {3} ]

are constructed using primitive values and, in the case of the record, other structured values.
Expressions
An expression is a formula used to construct values. An expression can be formed using a variety of syntactic constructs. The following are some examples of expressions. Each line is a separate expression.
""Hello World""             // a text value 
123                       // a number 
1 + 2                     // sum of two numbers 
{1, 2, 3}                 // a list of three numbers 
[ x = 1, y = 2 + 3 ]      // a record containing two fields: 
                          //        x and y 
(x, y) => x + y           // a function that computes a sum 
if 2 > 1 then 2 else 1    // a conditional expression 
let x = 1 + 1  in x * 2   // a let expression 
error ""A""                 // error with message ""A""

The simplest form of expression, as seen above, is a literal representing a value.
More complex expressions are built from other expressions, called sub-expressions. For example:
1 + 2

The above expression is actually composed of three expressions. The 1 and 2 literals are subexpressions of the parent expression 1 + 2.
Executing the algorithm defined by the syntactic constructs used in an expression is called evaluating the expression. Each kind of expression has rules for how it is evaluated. For example, a literal expression like 1 will produce a constant value, while the expression a + b will take the resulting values produced by evaluating two other expressions (a and b) and add them together according to some set of rules.
Environments and variables
Expressions are evaluated within a given environment. An environment is a set of named values, called variables. Each variable in an environment has a unique name within the environment called an identifier.
A top-level (or root) expression is evaluated within the global environment. The global environment is provided by the expression evaluator instead of being determined from the contents of the expression being evaluated. The contents of the global environment includes the standard library definitions and can be affected by exports from sections from some set of documents. (For simplicity, the examples in this section will assume an empty global environment. That is, it is assumed that there is no standard library and that there are no other section-based definitions.)
The environment used to evaluate a sub-expression is determined by the parent expression. Most parent expression kinds will evaluate a sub-expression within the same environment they were evaluated within, but some will use a different environment. The global environment is the parent environment within which the global expression is evaluated.
For example, the record-initializer-expression evaluates the sub-expression for each field with a modified environment. The modified environment includes a variable for each of the fields of the record, except the one being initialized. Including the other fields of the record allows the fields to depend upon the values of the fields. For example:
[  
    x = 1,          // environment: y, z 
    y = 2,          // environment: x, z 
    z = x + y       // environment: x, y
] 

Similarly, the let-expression evaluates the sub-expression for each variable with an environment containing each of the variables of the let except the one being initialized. The let-expression evaluates the expression following the in with an environment containing all the variables:
let 

    x = 1,          // environment: y, z 
    y = 2,          // environment: x, z 
    z = x + y       // environment: x, y
in
    x + y + z       // environment: x, y, z

(It turns out that both record-initializer-expression and let-expression actually define two environments, one of which does include the variable being initialized. This is useful for advanced recursive definitions and is covered in Identifier references .
To form the environments for the sub-expressions, the new variables are ""merged"" with the variables in the parent environment. The following example shows the environments for nested records:
[
    a = 
    [ 

        x = 1,      // environment: b, y, z 
        y = 2,      // environment: b, x, z 
        z = x + y   // environment: b, x, y 
    ], 
    b = 3           // environment: a
]  

The following example shows the environments for a record nested within a let:
Let
    a =
    [
        x = 1,       // environment: b, y, z 
        y = 2,       // environment: b, x, z 
        z = x + y    // environment: b, x, y 
    ], 
    b = 3            // environment: a 
in 
    a[z] + b         // environment: a, b

Merging variables with an environment may introduce a conflict between variables (since each variable in an environment must have a unique name). The conflict is resolved as follows: if the name of a new variable being merged is the same as an existing variable in the parent environment, then the new variable will take precedence in the new environment. In the following example, the inner (more deeply nested) variable x will take precedence over the outer variable x.
[
    a =
    [ 
        x = 1,       // environment: b, x (outer), y, z 
        y = 2,       // environment: b, x (inner), z 
        z = x + y    // environment: b, x (inner), y 
    ], 
    b = 3,           // environment: a, x (outer) 
    x = 4            // environment: a, b
]  


Identifier references
An identifier-reference is used to refer to a variable within an environment.
identifier-expression:
      identifier-reference
identifier-reference:
      exclusive-identifier-reference
      inclusive-identifier-reference
The simplest form of identifier reference is an exclusive-identifier-reference:
exclusive-identifier-reference:
      identifier
It is an error for an exclusive-identifier-reference to refer to a variable that is not part of the environment of the expression that the identifier appears within.
It is an error for an exclusive-identifier-reference to refer to an identifier that is currently being initialized if the referenced identifier is defined inside a record-initializer-expression or let-expression. Instead, an inclusive-identifier-reference can be used to gain access to the environment that includes the identifier being initialized. If an inclusive-identifier-reference is used in any other situation, then it is equivalent to an exclusive-identifier-reference.
inclusive-identifier-reference:
      @  identifier
This is useful when defining recursive functions since the name of the function would normally not be in scope.
[ 
    Factorial = (n) =>
        if n <= 1 then
            1
        else
            n * @Factorial(n - 1),  // @ is scoping operator

    x = Factorial(5) 
]

As with a record-initializer-expression, an inclusive-identifier-reference can be used within a let-expression to access the environment that includes the identifier being initialized.
Order of evaluation
Consider the following expression which initializes a record:
[ 
    C = A + B, 
    A = 1 + 1, 
    B = 2 + 2 
]

When evaluated, this expression produces the following record value:
[ 
    C = 6, 
    A = 2, 
    B = 4 
]

The expression states that in order to perform the A + B calculation for field C, the values of both field A and field B must be known. This is an example of a dependency ordering of calculations that is provided by an expression. The M evaluator abides by the dependency ordering provided by expressions, but is free to perform the remaining calculations in any order it chooses. For example, the computation order could be:
A = 1 + 1 
B = 2 + 2 
C = A + B

Or it could be:
B = 2 + 2 
A = 1 + 1 
C = A + B

Or, since A and B do not depend on each other, they can be computed concurrently:
    B = 2 + 2   concurrently with   A = 1 + 1
    C = A + B
Side effects
Allowing an expression evaluator to automatically compute the order of calculations for cases where there are no explicit dependencies stated by the expression is a simple and powerful computation model.
It does, however, rely on being able to reorder computations. Since expressions can call functions, and those functions could observe state external to the expression by issuing external queries, it is possible to construct a scenario where the order of calculation does matter, but is not captured in the partial order of the expression. For example, a function may read the contents of a file. If that function is called repeatedly, then external changes to that file can be observed and, therefore, reordering can cause observable differences in program behavior. Depending on such observed evaluation ordering for the correctness of an M expression causes a dependency on particular implementation choices that might vary from one evaluator to the next or may even vary on the same evaluator under varying circumstances.
Immutability
Once a value has been calculated, it is immutable, meaning it can no longer be changed. This simplifies the model for evaluating an expression and makes it easier to reason about the result since it is not possible to change a value once it has been used to evaluate a subsequent part of the expression. For instance, a record field is only computed when needed. However, once computed, it remains fixed for the lifetime of the record. Even if the attempt to compute the field raised an error, that same error will be raised again on every attempt to access that record field.
An important exception to the immutable-once-calculated rule applies to list, table, and binary values, which have streaming semantics. Streaming semantics allow M to transform data sets that don't fit into memory all at once. With streaming, the values returned when enumerating a given table, list, or binary value are produced on demand each time they're requested. Since the expressions defining the enumerated values are evaluated each time they're enumerated, the output they produce can be different across multiple enumerations. This doesn't mean that multiple enumerations always results in different values, just that they can be different if the data source or M logic being used is non-deterministic.
Also, note that function application is not the same as value construction. Library functions may expose external state (such as the current time or the results of a query against a database that evolves over time), rendering them non-deterministic. While functions defined in M will not, as such, expose any such non-deterministic behavior, they can if they are defined to invoke other functions that are non-deterministic.
A final source of non-determinism in M are errors. Errors stop evaluations when they occur (up to the level where they are handled by a try expression). It is not normally observable whether a + b caused the evaluation of a before b or b before a (ignoring concurrency here for simplicity). However, if the subexpression that was evaluated first raises an error, then it can be determined which of the two expressions was evaluated first."
Values,https://learn.microsoft.com/en-us/powerquery-m/m-spec-values,"Values
										
											Article05/16/2023
															
															3 contributors
														
										

	
		
			
		
		Feedback
	
 
		In this article
		
			
					
						Null
					
				
					
						Logical
					
				
					
						Number
					
				
					
						Time
					
				
					
						Date
					
				
					
						DateTime
					
				
					
						DateTimeZone
					
				
					
						Duration
					
				
					
						Text
					
				
					
						Binary
					
				
					
						List
					
				
					
						Record
					
				
					
						Table
					
				
					
						Function
					
				
					
						Type
					
				
		
	 
		
			Show 11 more
			
		
	 A value is data produced by evaluating an expression. This section describes the kinds of values in the M language. Each kind of value is associated with a literal syntax, a set of values that are of that kind, a set of operators defined over that set of values, and an intrinsic type ascribed to newly constructed values.
 
		
			
		
		Expand table
	


Kind
Literal




Null
null


Logical
true    false


Number
0    1    -1    1.5    2.3e-5


Time
#time(09,15,00)


Date
#date(2013,02,26)


DateTime
#datetime(2013,02,26, 09,15,00)


DateTimeZone
#datetimezone(2013,02,26, 09,15,00, 09,00)


Duration
#duration(0,1,30,0)


Text
""hello""


Binary
#binary(""AQID"")


List
{1, 2, 3}


Record
[ A = 1, B = 2 ]


Table
#table({""X"",""Y""},{{0,1},{1,0}})


Function
(x) => x + 1


Type
type { number }    type table [ A = any, B = text ]



The following sections cover each value kind in detail. Types and type ascription are defined formally in Types. Function values are defined in Functions. The following sections list the operators defined for each value kind and give examples. The full definition of operator semantics follows in Operators.
Null
A null value is used to represent the absence of a value, or a value of indeterminate or unknown state. A null value is written using the literal null. The following operators are defined for null values:
 
		
			
		
		Expand table
	


Operator
Result




x > y
Greater than


x >= y
Greater than or equal


x < y
Less than


x <= y
Less than or equal


x = y
Equal


x <> y
Not equal


x ?? y
Coalesce



The native type of the null value is the intrinsic type null.
Logical
A logical value is used for Boolean operations has the value true or false. A logical value is written using the literals true and false. The following operators are defined for logical values:
 
		
			
		
		Expand table
	


Operator
Result




x > y
Greater than


x >= y
Greater than or equal


x < y
Less than


x <= y
Less than or equal


x = y
Equal


x <> y
Not equal


x or y
Conditional logical OR


x ?? y
Coalesce


x and y
Conditional logical AND


not x
Logical NOT



The native type of both logical values (true and false) is the intrinsic type logical.
Number
A number value is used for numeric and arithmetic operations. The following are examples of number literals:
3.14  // Fractional number 
-1.5  // Fractional number 
1.0e3 // Fractional number with exponent
123   // Whole number 
1e3   // Whole number with exponent 
0xff  // Whole number in hex (255)

A number is represented with at least the precision of a Double (but may retain more precision). The Double representation is congruent with the IEEE 64-bit double precision standard for binary floating point arithmetic defined in [IEEE 754-2008]. (The Double representation have an approximate dynamic range from 5.0 x 10324 to 1.7 x 10308 with a precision of 15-16 digits.)
The following special values are also considered to be number values:

Positive zero and negative zero. In most situations, positive zero and negative zero behave identically as the simple value zero, but certain operations distinguish between the two.

Positive infinity (#infinity) and negative infinity (-#infinity). Infinities are produced by such operations as dividing a non-zero number by zero. For example, 1.0 / 0.0 yields positive infinity, and -1.0 / 0.0 yields negative infinity.

The Not-a-Number value (#nan), often abbreviated NaN. NaNs are produced by invalid floating-point operations, such as dividing zero by zero.


Binary mathematical operations are performed using a Precision. The precision determines the domain to which the operands are rounded and the domain in which the operation is performed. In the absence of an explicitly specified precision, such operations are performed using Double Precision.

If the result of a mathematical operation is too small for the destination format, the result of the operation becomes positive zero or negative zero.

If the result of a mathematical operation is too large for the destination format, the result of the operation becomes positive infinity or negative infinity.

If a mathematical operation is invalid, the result of the operation becomes NaN.

If one or both operands of a floating-point operation is NaN, the result of the operation becomes NaN.


The following operators are defined for number values:
 
		
			
		
		Expand table
	


Operator
Result




x > y
Greater than


x >= y
Greater than or equal


x < y
Less than


x <= y
Less than or equal


x = y
Equal


x <> y
Not equal


x + y
Sum


x - y
Difference


x * y
Product


x / y
Quotient


x ?? y
Coalesce


+x
Unary plus


-x
Negation



The native type of number values is the intrinsic type number.
Time
A time value stores an opaque representation of time of day. A time is encoded as the number of ticks since midnight, which counts the number of 100-nanosecond ticks that have elapsed on a 24-hour clock. The maximum number of ticks since midnight corresponds to 23:59:59.9999999 hours.
Although there is no literal syntax for times, several standard library functions are provided to construct them. Times may also be constructed using the intrinsic function #time:
#time(hour, minute, second)

The following must hold or an error with reason code Expression.Error is raised:
0 ≤ hour ≤ 24
0 ≤ minute ≤ 59
0 ≤ second ≤ 59
In addition, if hour = 24, then minute and second must be zero.
The following operators are defined for time values:
 
		
			
		
		Expand table
	


Operator
Result




x = y
Equal


x <> y
Not equal


x >= y
Greater than or equal


x > y
Greater than


x < y
Less than


x <= y
Less than or equal


x ?? y
Coalesce



The following operators permit one or both of their operands to be a date:
 
		
			
		
		Expand table
	


Operator
Left Operand
Right Operand
Meaning




x + y
time
duration
Date offset by duration


x + y
duration
time
Date offset by duration


x - y
time
duration
Date offset by negated duration


x - y
time
time
Duration between dates


x & y
date
time
Merged datetime



The native type of time values is the intrinsic type time.
Date
A date value stores an opaque representation of a specific day. A date is encoded as a number of days since epoch, starting from January 1, 0001 Common Era on the Gregorian calendar. The maximum number of days since epoch is 3652058, corresponding to December 31, 9999.
Although there is no literal syntax for dates, several standard library functions are provided to construct them. Dates may also be constructed using the intrinsic function #date:
#date(year, month, day)

The following must hold or an error with reason code Expression.Error is raised:
1 ≤ year ≤ 9999
1 ≤ month ≤ 12
1 ≤ day ≤ 31
In addition, the day must be valid for the chosen month and year.
The following operators are defined for date values:
 
		
			
		
		Expand table
	


Operator
Result




x = y
Equal


x <> y
Not equal


x >= y
Greater than or equal


x > y
Greater than


x < y
Less than


x <= y
Less than or equal


x ?? y
Coalesce



The following operators permit one or both of their operands to be a date:
 
		
			
		
		Expand table
	


Operator
Left Operand
Right Operand
Meaning




x + y
date
duration
Date offset by duration


x + y
duration
date
Date offset by duration


x - y
date
duration
Date offset by negated duration


x - y
date
date
Duration between dates


x & y
date
time
Merged datetime



The native type of date values is the intrinsic type date.
DateTime
A datetime value contains both a date and time.
Although there is no literal syntax for datetimes, several standard library functions are provided to construct them. Datetimes may also be constructed using the intrinsic function #datetime:
#datetime(year, month, day, hour, minute, second)

The following must hold or an error with reason code Expression.Error is raised:
1 ≤ year ≤ 9999
1 ≤ month ≤ 12
1 ≤ day ≤ 31
0 ≤ hour ≤ 23
0 ≤ minute ≤ 59
0 ≤ second ≤ 59
In addition, the day must be valid for the chosen month and year.
The following operators are defined for datetime values:
 
		
			
		
		Expand table
	


Operator
Result




x = y
Equal


x <> y
Not equal


x >= y
Greater than or equal


x > y
Greater than


x < y
Less than


x <= y
Less than or equal


x ?? y
Coalesce



The following operators permit one or both of their operands to be a datetime:
 
		
			
		
		Expand table
	


Operator
Left Operand
Right Operand
Meaning




x + y
datetime
duration
Datetime offset by duration


x + y
duration
datetime
Datetime offset by duration


x - y
datetime
duration
Datetime offset by negated duration


x - y
datetime
datetime
Duration between datetimes



The native type of datetime values is the intrinsic type datetime.
DateTimeZone
A datetimezone value contains a datetime and a timezone. A timezone is encoded as a number of minutes offset from UTC, which counts the number of minutes the time portion of the datetime should be offset from Universal Coordinated Time (UTC). The minimum number of minutes offset from UTC is -840, representing a UTC offset of -14:00, or fourteen hours earlier than UTC. The maximum number of minutes offset from UTC is 840, corresponding to a UTC offset of 14:00.
Although there is no literal syntax for datetimezones, several standard library functions are provided to construct them. Datetimezones may also be constructed using the intrinsic function #datetimezone:
#datetimezone(
       year, month, day,
       hour, minute, second,
       offset-hours, offset-minutes)

The following must hold or an error with reason code Expression.Error is raised:
1 ≤ year ≤ 9999
1 ≤ month ≤ 12
1 ≤ day ≤ 31
0 ≤ hour ≤ 23
0 ≤ minute ≤ 59
0 ≤ second ≤ 59
-14 ≤ offset-hours ≤ 14
-59 ≤ offset-minutes ≤ 59
In addition, the day must be valid for the chosen month and year and, if offset-hours = 14, then offset-minutes <= 0 and, if offset-hours = -14, then offset-minutes >= 0.
The following operators are defined for datetimezone values:
 
		
			
		
		Expand table
	


Operator
Result




x = y
Equal


x <> y
Not equal


x >= y
Greater than or equal


x > y
Greater than


x < y
Less than


x <= y
Less than or equal


x ?? y
Coalesce



The following operators permit one or both of their operands to be a datetimezone:
 
		
			
		
		Expand table
	


Operator
Left Operand
Right Operand
Meaning




x + y
datetimezone
duration
Datetimezone offset by duration


x + y
duration
datetimezone
Datetimezone offset by duration


x - y
datetimezone
duration
Datetimezone offset by negated duration


x - y
datetimezone
datetimezone
Duration between datetimezones



The native type of datetimezone values is the intrinsic type datetimezone.
Duration
A duration value stores an opaque representation of the distance between two points on a timeline measured 100-nanosecond ticks. The magnitude of a duration can be either positive or negative, with positive values denoting progress forwards in time and negative values denoting progress backwards in time. The minimum value that can be stored in a duration is -9,223,372,036,854,775,808 ticks, or 10,675,199 days 2 hours 48 minutes 05.4775808 seconds backwards in time. The maximum value that can be stored in a duration is 9,223,372,036,854,775,807 ticks, or 10,675,199 days 2 hours 48 minutes 05.4775807 seconds forwards in time.
Although there is no literal syntax for durations, several standard library functions are provided to construct them. Durations may also be constructed using the intrinsic function #duration:
#duration(0, 0, 0, 5.5)          // 5.5 seconds 
#duration(0, 0, 0, -5.5)         // -5.5 seconds 
#duration(0, 0, 5, 30)           // 5.5 minutes 
#duration(0, 0, 5, -30)          // 4.5 minutes 
#duration(0, 24, 0, 0)           // 1 day 
#duration(1, 0, 0, 0)            // 1 day

The following operators are defined on duration values:
 
		
			
		
		Expand table
	


Operator
Result




x = y
Equal


x <> y
Not equal


x >= y
Greater than or equal


x > y
Greater than


x < y
Less than


x <= y
Less than or equal


x ?? y
Coalesce



Additionally, the following operators allow one or both of their operands to be a duration value:
 
		
			
		
		Expand table
	


Operator
Left Operand
Right Operand
Meaning




x + y
datetime
duration
Datetime offset by duration


x + y
duration
datetime
Datetime offset by duration


x + y
duration
duration
Sum of durations


x - y
datetime
duration
Datetime offset by negated duration


x - y
datetime
datetime
Duration between datetimes


x - y
duration
duration
Difference of durations


x * y
duration
number
N times a duration


x * y
number
duration
N times a duration


x / y
duration
number
Fraction of a duration



The native type of duration values is the intrinsic type duration.
Text
A text value represents a sequence of Unicode characters. Text values have a literal form conformant to the following grammar:
_text-literal:
      "" text-literal-charactersopt  ""
text-literal-characters:
      text-literal-character text-literal-charactersopt
text-literal-character:
      single-text-character
      character-escape-sequence
      double-quote-escape-sequence
single-text-character:
      Any character except "" (U+0022) or # (U+0023) followed by ( (U+0028)
double-quote-escape-sequence:
      """" (U+0022, U+0022)
The following is an example of a text value:
""ABC"" // the text value ABC

The following operators are defined on text values:
 
		
			
		
		Expand table
	


Operator
Result




x = y
Equal


x <> y
Not equal


x >= y
Greater than or equal


x > y
Greater than


x < y
Less than


x <= y
Less than or equal


x & y
Concatenation


x ?? y
Coalesce



The native type of text values is the intrinsic type text.
Binary
A binary value represents a sequence of bytes.
Although there is no literal syntax for binary values, several standard library functions are provided to construct them. Binary values may also be constructed using the intrinsic function #binary.
The following example constructs a binary value from a list of bytes:
#binary( {0x00, 0x01, 0x02, 0x03} )

The following operators are defined on binary values:
 
		
			
		
		Expand table
	


Operator
Result




x = y
Equal


x <> y
Not equal


x >= y
Greater than or equal


x > y
Greater than


x < y
Less than


x <= y
Less than or equal


x ?? y
Coalesce



The native type of binary values is the intrinsic type binary.
List
A list value is a value which produces a sequence of values when enumerated. A value produced by a list can contain any kind of value, including a list. Lists can be constructed using the initialization syntax, as follows:
list-expression:
      { item-listopt  }
item-list:
      item
      item ,  item-list
item:
      expression
      expression  .. expression
The following is an example  of a list-expression that defines a list with three text values: ""A"", ""B"", and ""C"".
{""A"", ""B"", ""C""}

The value ""A"" is the first item in the list, and the value ""C"" is the last item in the list.

The items of a list are not evaluated until they are accessed.
While list values constructed using the list syntax will produce items in the order they appear in item-list, in general, lists returned from library functions may produce a different set or a different number of values each time they are enumerated.

To include a sequence of whole number in a list, the a..b form can be used:
{ 1, 5..9, 11 }     // { 1, 5, 6, 7, 8, 9, 11 }

The number of items in a list, known as the list count, can be determined using the List.Count function.
List.Count({true, false})  // 2 
List.Count({})             // 0

A list may effectively have an infinite number of items; List.Count for such lists is undefined and may either raise an error or not terminate.
If a list contains no items, it is called an empty list. An empty list is written as:
{}  // empty list

The following operators are defined for lists:
 
		
			
		
		Expand table
	


Operator
Result




x = y
Equal


x <> y
Not equal


x & y
Concatenate


x ?? y
Coalesce



For example:
{1, 2} & {3, 4, 5}   // {1, 2, 3, 4, 5} 
{1, 2} = {1, 2}      // true 
{2, 1} <> {1, 2}     // true

The native type of list values is the intrinsic type list, which specifies an item type of any.
Record
A record value is an ordered sequence of fields. A field consists of a field name, which is a text value that uniquely identifies the field within the record, and a field value. The field value can be any kind of value, including record. Records can be constructed using initialization syntax, as follows:
record-expression:
      [  field-listopt  ] field-list:
      field
      field  ,  field-list
field:
      field-name  =  expression
field-name:
      generalized-identifier
      quoted-identifier
The following example constructs a record with a field named x with value 1, and a field named y with value 2.
[ x = 1, y = 2 ]

The following example constructs a record with a field named a with a nested record value. The nested record has a field named b with value 2.
[ a = [ b = 2 ] ]

The following holds when evaluating a record expression:

The expression assigned to each field name is used to determine the value of the associated field.

If the expression assigned to a field name produces a value when evaluated, then that becomes the value of the field of the resulting record.

If the expression assigned to a field name raises an error when evaluated, then the fact that an error was raised is recorded with the field along with the error value that was raised. Subsequent access to that field will cause an error to be re-raised with the recorded error value.

The expression is evaluated in an environment like the parent environment only with variables merged in that correspond to the value of every field of the record, except the one being initialized.

A value in a record is not evaluated until the corresponding field is accessed.

A value in a record is evaluated at most once.

The result of the expression is a record value with an empty metadata record.

The order of the fields within the record is defined by the order that they appear in the record-initializer-expression.

Every field name that is specified must be unique within the record, or it is an error. Names are compared using an ordinal comparison.


    [ x = 1, x = 2 ] // error: field names must be unique 
    [ X = 1, x = 2 ] // OK

A record with no fields is called an empty record, and is written as follows:
[] // empty record

Although the order of the fields of a record is not significant when accessing a field or comparing two records, it is significant in other contexts such as when the fields of a record are enumerated.
The same two records produce different results when the fields are obtained:
Record.FieldNames([ x = 1, y = 2 ]) // [ ""x"", ""y"" ] 
Record.FieldNames([ y = 1, x = 2 ]) // [ ""y"", ""x"" ]

The number of fields in a record can be determined using the Record.FieldCount function. For example:
Record.FieldCount([ x = 1, y = 2 })  // 2 
Record.FieldCount([])                // 0

In addition to using the record initialization syntax [ ], records can be constructed from a list of values, and a list of field names or a record type. For example:
Record.FromList({1, 2}, {""a"", ""b""})

The above is equivalent to:
[ a = 1, b = 2 ]

The following operators are defined for record values:
 
		
			
		
		Expand table
	


Operator
Result




x = y
Equal


x <> y
Not equal


x & y
Merge


x ?? y
Coalesce



The following examples illustrate the above operators. Note that record merge uses the fields from the right operand to override fields from the left operand, should there be an overlap in field names.
[ a = 1, b = 2 ] & [ c = 3 ]    // [ a = 1, b = 2, c = 3 ] 
[ a = 1, b = 2 ] & [ a = 3 ]    // [ a = 3, b = 2 ] 
[ a = 1, b = 2 ] = [ b = 2, a = 1 ]         // true 
[ a = 1, b = 2, c = 3 ] <> [ a = 1, b = 2 ] // true

The native type of record values is the intrinsic type record, which specifies an open empty list of fields.
Table
A table value is an ordered sequence of rows. A row is an ordered sequence of column values. The table's type determines the length of all rows in the table, the names of the table's columns, the types of the table's columns, and the structure of the table's keys (if any).
Although there is no literal syntax for tables, several standard library functions are provided to construct them. Tables may also be constructed using the intrinsic function #table.
The following example constructs a table from a list of column names and a list of rows. The resulting table will contain two columns of type any and three rows.
#table({""x"", ""x^2""}, {{1,1}, {2,4}, {3,9}})

#table can also be used to specify a full table type:
#table(
    type table [Digit = number, Name = text],  
    {{1,""one""}, {2,""two""}, {3,""three""}} 
    )

Here the new table value has a table type that specifies column names and column types.
The following operators are defined for table values:
 
		
			
		
		Expand table
	


Operator
Result




x = y
Equal


x <> y
Not equal


x & y
Concatenation


x ?? y
Coalesce



Table concatenation aligns like-named columns and fills in null for columns appearing in only one of the operand tables. The following example illustrates table concatenation:
  #table({""A"",""B""}, {{1,2}}) 
& #table({""B"",""C""}, {{3,4}})

 
		
			
		
		Expand table
	


A
B
C




1
2
null


null
3
4



The native type of table values is a custom table type (derived from the intrinsic type table) that lists the column names, specifies all column types to be any, and has no keys. (Go to Table types for details on table types.)
Function
A function value is a value that maps a set of arguments to a single value. The details of function values are described in Functions.
Type
A type value is a value that classifies other values. The details of type values are described in Types."
Types,https://learn.microsoft.com/en-us/powerquery-m/m-spec-types,"Types
										
											Article01/31/2024
															
															3 contributors
														
										

	
		
			
		
		Feedback
	
 
		In this article
		
			
					
						Primitive Types
					
				
					
						Any Type
					
				
					
						List Types
					
				
					
						Record Types
					
				
					
						Function Types
					
				
					
						Table types
					
				
					
						Nullable types
					
				
					
						Ascribed type of a value
					
				
					
						Type equivalence and compatibility
					
				
		
	 
		
			Show 5 more
			
		
	 A type value is a value that classifies other values. A value that is classified by a type is said to conform to that type. The M type system consists of the following kinds of types:

Primitive types, which classify primitive values (binary, date, datetime, datetimezone, duration, list, logical, null, number, record, text, time, type) and also include a number of abstract types (function, table, any, anynonnull and none)

Record types, which classify record values based on field names and value types

List types, which classify lists using a single item base type

Function types, which classify function values based on the types of their parameters and return values

Table types, which classify table values based on column names, column types, and keys

Nullable types, which classifies the value null in addition to all the values classified by a base type

Type types, which classify values that are types


The set of primitive types includes the types of primitive values, and a number of abstract types, which are types that do not uniquely classify any values: function, table, any, anynonnull and none. All function values conform to the abstract type function, all table values to the abstract type table, all values to the abstract type any, all non-null values to the abstract type anynonnull, and no values to the abstract type none. An expression of type none must raise an error or fail to terminate since no value could be produced that conforms to type none. Note that the primitive types function and table are abstract because no function or table is directly of those types, respectively. The primitive types record and list are non-abstract because they represent an open record with no defined fields and a list of type any, respectively.
All types that are not members of the closed set of primitive types plus their nullable counterparts are collectively referred to as custom types. Custom types can be written using a type-expression:
type-expression:
      primary-expression
      type primary-type
type:
      primary-expression
      primary-type
primary-type:
      primitive-type
      record-type
      list-type
      function-type
      table-type
      nullable-type
primitive-type: one of
      any anynonnull binary date datetime datetimezone duration function list logical
      none null number record table text time type
The primitive-type names are contextual keywords recognized only in a type context. The use of parentheses in a type context moves the grammar back to a regular expression context, requiring the use of the type keyword to move back into a type context. For example, to invoke a function in a type context, parentheses can be used:
type nullable ( Type.ForList({type number}) )   
// type nullable {number}

Parentheses can also be used to access a variable whose name collides with a primitive-type name:
let  record = type [ A = any ]  in  type {(record)} 
// type {[ A = any ]}

The following example defines a type that classifies a list of numbers:
type { number }

Similarly, the following example defines a custom type that classifies records with mandatory fields named X and Y whose values are numbers:
type [ X = number, Y = number ]

The ascribed type of a value is obtained using the standard library function Value.Type, as shown in the following examples:
Value.Type( 2 )                 // type number 
Value.Type( {2} )               // type list 
Value.Type( [ X = 1, Y = 2 ] )  // type record

The is operator is used to determine whether a value's type is compatible with a given type, as shown in the following examples:
1 is number          // true 
1 is text            // false 
{2} is list          // true

The as operator checks if the value is compatible with the given type, and raises an error if it is not. Otherwise, it returns the original value.
Value.Type( 1 as number )   // type number 
{2} as text                 // error, type mismatch

Note that the is and as operators only accept nullable primitive types as their right operand. M does not provide means to check values for conformance to custom types.
A type X is compatible with a type Y if and only if all values that conform to X also conform to Y. All types are compatible with type any and no types (but none itself) are compatible with type none. The following graph shows the compatibility relation. (Type compatibility is reflexive and transitive. It forms a lattice with type any as the top and type none as the bottom value.) The names of abstract types are set in italics.

The following operators are defined for type values:
 
		
			
		
		Expand table
	


Operator
Result




x = y
Equal


x <> y
Not equal


x ?? y
Coalesce



The native type of type values is the intrinsic type type.
Primitive Types
Types in the M language form a disjoint hierarchy rooted at type any, which is the type that classifies all values. Any M value conforms to exactly one primitive subtype of any. The closed set of primitive types deriving from type any are as follows:

type null,  which classifies the null value.
type logical, which classifies the values true and false.
type number, which classifies number values.
type time, which classifies time values.
type date, which classifies date values.
type datetime, which classifies datetime values.
type datetimezone, which classifies datetimezone values.
type duration, which classifies duration values.
type text, which classifies text values.
type binary, which classifies binary values.
type type, which classifies type values.
type list, which classifies list values.
type record, which classifies record values.
type table, which classifies table values.
type function, which classifies function values.
type anynonnull, which classifies all values excluding null.
type none, which classifies no values.

Any Type
The type any is abstract, classifies all values in M, and all types in M are compatible with any. Variables of type any can be bound to all possible values. Since any is abstract, it cannot be ascribed to values—that is, no value is directly of type any.
List Types
Any value that is a list conforms to the intrinsic type list, which does not place any restrictions on the items within a list value.
list-type:
      {  item-type  }
item-type:
      type
The result of evaluating a list-type is a list type value whose base type is list.
The following examples illustrate the syntax for declaring homogeneous list types:
type { number }        // list of numbers type 
     { record }        // list of records type
     {{ text }}        // list of lists of text values

A value conforms to a list type if the value is a list and each item in that list value conforms to the list type's item type.
The item type of a list type indicates a bound: all items of a conforming list conform to the item type.
Record Types
Any value that is a record conforms to the intrinsic type record, which does not place any restrictions on the field names or values within a record value. A record-type value is used to restrict the set of valid names as well as the types of values that are permitted to be associated with those names.
record-type:
      [ open-record-marker  ]
      [  field-specification-listopt  ]
      [  field-specification-list ,  open-record-marker  ]
field-specification-list:
      field-specification
      field-specification  ,  field-specification-list
field-specification:
      optionalopt field-name field-type-specificationopt
field-type-specification:
      = field-type
field-type:
      type
open-record-marker:
      ...
The result of evaluating a record-type is a type value whose base type is record.
The following examples illustrate the syntax for declaring record types:
type [ X = number, Y = number] 
type [ Name = text, Age = number ]
type [ Title = text, optional Description = text ] 
type [ Name = text, ... ]

Record types are closed by default, meaning that additional fields not present in the fieldspecification-list are not allowed to be present in conforming values. Including the openrecord-marker in the record type declares the type to be open, which permits fields not present in the field specification list. The following two expressions are equivalent:
type record   // primitive type classifying all records 
type [ ... ]  // custom type classifying all records

A value conforms to a record type if the value is a record and each field specification in the record type is satisfied. A field specification is satisfied if any of the following are true:

A field name matching the specification's identifier exists in the record and the associated value conforms to the specification's type

The specification is marked as optional and no corresponding field name is found in the record


A conforming value may contain field names not listed in the field specification list if and only if the record type is open.
Function Types
Any function value conforms to the primitive type function, which does not place any restrictions on the types of the function's formal parameters or the function's return value. A custom function-type value is used to place type restrictions on the signatures of conformant function values.
function-type:
      function (  parameter-specification-listopt ) function-return-type
parameter-specification-list:
      required-parameter-specification-list
      required-parameter-specification-list  ,  optional-parameter-specification-list
      optional-parameter-specification-list
required-parameter-specification-list:
      required-parameter-specification
      required-parameter-specification , required-parameter-specification-list
required-parameter-specification:
      parameter-specification
optional-parameter-specification-list:
      optional-parameter-specification
      optional-parameter-specification , optional-parameter-specification-list
optional-parameter-specification:
      optional parameter-specification
parameter-specification:
      parameter-name parameter-type
function-return-type:
      assertion
assertion:
      as  nullable-primitive-type
The result of evaluating a function-type is a type value whose base type is function.
The following examples illustrate the syntax for declaring function types:
type function (x as text) as number 
type function (y as number, optional z as text) as any

A function value conforms to a function type if the return type of the function value is compatible with the function type's return type and each parameter specification of the function type is compatible to the positionally corresponding formal parameter of the function. A parameter specification is compatible with a formal parameter if the specified parameter-type type is compatible with the type of the formal parameter and the parameter specification is optional if the formal parameter is optional.
Formal parameter names are ignored for the purposes of determining function type conformance.
Specifying a parameter as optional implicitly makes its type nullable. The following create identical function types:
type function (optional x as text) as any
type function (optional x as nullable text) as any

Table types
A table-type value is used to define the structure of a table value.
table-type:
      table row-type
row-type:
      [   field-specification-listopt  ]
The result of evaluating a table-type is a type value whose base type is table.
The row type of a table specifies the column names and column types of the table as a closed record type. So that all table values conform to the type table, its row type is type record (the empty open record type). Thus, type table is abstract since no table value can have type table's row type (but all table values have a row type that is compatible with type table's row type). The following example shows the construction of a table type:
type table [A = text, B = number, C = binary] 
// a table type with three columns named A, B, and C 
// of column types text, number, and binary, respectively

A table-type value also carries the definition of a table value's keys. A key is a set of column names. At most one key can be designated as the table's primary key. (Within M, table keys have no semantic meaning. However, it is common for external data sources, such as databases or OData feeds, to define keys over tables. Power Query uses key information to improve performance of advanced functionality, such as cross-source join operations.)
The standard library functions Type.TableKeys, Type.AddTableKey, and Type.ReplaceTableKeys can be used to obtain the keys of a table type, add a key to a table type, and replace all keys of a table type, respectively.
Type.AddTableKey(tableType, {""A"", ""B""}, false) 
// add a non-primary key that combines values from columns A and B 
Type.ReplaceTableKeys(tableType, {}) 
// returns type value with all keys removed

Nullable types
For any type T, a nullable variant can be derived by using nullable-type:
nullable-type:
      nullable type
The result is an abstract type that allows values of type T or the value null.
42 is nullable number             // true null is
nullable number                   // true

Ascription of type nullable T reduces to ascription of type null or type T. (Recall that nullable types are abstract and no value can be directly of abstract type.)
Value.Type(42 as nullable number)       // type number
Value.Type(null as nullable number)     // type null

The standard library functions Type.IsNullable and Type.NonNullable can be used to test a type for nullability and to remove nullability from a type.
The following hold (for any type T):

type T is compatible with type nullable T
Type.NonNullable(type T) is compatible with type T

The following are pairwise equivalent (for any type T):
    type nullable any
    any
    Type.NonNullable(type any)
    type anynonnull
    type nullable none
    type null
    Type.NonNullable(type null)
    type none
    type nullable nullable T
    type nullable T
    Type.NonNullable(Type.NonNullable(type T))
    Type.NonNullable(type T)
    Type.NonNullable(type nullable T)
    Type.NonNullable(type T)
    type nullable (Type.NonNullable(type T))
    type nullable T
Ascribed type of a value
A value's ascribed type is the type to which a value is declared to conform.
A value may be ascribed a type using the library function Value.ReplaceType. This function either returns a new value with the type ascribed or raises an error if the new type is incompatible with the value.
When a value is ascribed a type, only a limited conformance check occurs:

The type being ascribed must be non-abstract, non-nullable, and compatible with the value's intrinsic (native) primitive-type.
When a custom type that defines structure is ascribed, it must match the structure of the value.

For records: The type must be closed, must define the same number of fields as the value, and must not contain any optional fields. (The type's field names and field types will replace those currently associated with the record. However, existing field values will not be checked against the new field types.)
For tables: The type must define the same number of columns as the value. (The type's column names and column types will replace those currently associated with the table. However, existing column values will not be checked against the new column types.)
For functions: The type must define the same number of required parameters, as well as the same number of optional parameters, as the value. (The type's parameter and return assertions, as well as its parameter names, will replace those associated with the function value's current type. However, the new assertions will have no effect on the actual behavior of the function.)
For lists: The value must be a list. (However, existing list items will not be checked against the new item type.)



Library functions may choose to compute and ascribe complex types to results based on the ascribed types of the input values.
The ascribed type of a value may be obtained using the library function Value.Type. For example:
Value.Type( Value.ReplaceType( {1}, type {number} ) 
// type {number}

Type equivalence and compatibility
Type equivalence is not defined in M. An M implementation may optionally choose to use its own rules to perform equality comparisons between type values. Comparing two type values for equality should evaluate to true if they are considered identical by the implementation, and false otherwise. In either case, the response returned must be consistent if the same two values are repeatedly compared. Note that within a given implementation, comparing some identical type values (such as (type text) = (type text)) may return true, while comparing others (such as (type [a = text]) = (type [a = text])) may not.
Compatibility between a given type and a nullable primitive type can be determined using the library function Type.Is, which accepts an arbitrary type value as its first and a nullable primitive type value as its second argument:
Type.Is(type text, type nullable text)  // true 
Type.Is(type nullable text, type text)  // false 
Type.Is(type number, type text)         // false 
Type.Is(type [a=any], type record)      // true 
Type.Is(type [a=any], type list)        // false

There is no support in M for determining compatibility of a given type with a custom type.
The standard library does include a collection of functions to extract the defining characteristics from a custom type, so specific compatibility tests can be implemented as M expressions. Below are some examples; consult the M library specification for full details.
Type.ListItem( type {number} ) 
  // type number 
Type.NonNullable( type nullable text ) 
  // type text 
Type.RecordFields( type [A=text, B=time] ) 
  // [ A = [Type = type text, Optional = false], 
  //   B = [Type = type time, Optional = false] ] 
Type.TableRow( type table [X=number, Y=date] ) 
  // type [X = number, Y = date] 
Type.FunctionParameters(
        type function (x as number, optional y as text) as number) 
  // [ x = type number, y = type nullable text ] 
Type.FunctionRequiredParameters(
        type function (x as number, optional y as text) as number) 
  // 1 
Type.FunctionReturn(
        type function (x as number, optional y as text) as number) 
  // type number"
Operators,https://learn.microsoft.com/en-us/powerquery-m/m-spec-operators,"Operator behavior
										
											Article07/31/2024
															
															4 contributors
														
										

	
		
			
		
		Feedback
	
 
		In this article
		
			
					
						Operator precedence
					
				
					
						Operators and metadata
					
				
					
						Structurally recursive operators
					
				
					
						Selection and Projection Operators
					
				
					
						Metadata operator
					
				
					
						Equality operators
					
				
					
						Relational operators
					
				
					
						Conditional logical operators
					
				
					
						Arithmetic Operators
					
				
					
						Structure Combination
					
				
					
						Unary operators
					
				
					
						Type operators
					
				
		
	 
		
			Show 8 more
			
		
	 This section defines the behavior of the various M operators.
Operator precedence
When an expression contains multiple operators, the precedence of the operators controls the order in which the individual operators are evaluated. For example, the expression x + y * z is evaluated as x + (y * z) because the * operator has higher precedence than the binary + operator. The precedence of an operator is established by the definition of its associated grammar production. For example, an additive-expression consists of a sequence of multiplicative-expression's separated by + or - operators, thus giving the + and - operators lower precedence than the * and / operators.
The parenthesized-expression production can be used to change the default precedence ordering.
parenthesized-expression:
      (  expression  )
For example:
1 + 2 * 3       // 7 
(1 + 2) * 3     // 9

The following table summarizes the M operators, listing the operator categories in order of precedence from highest to lowest. Operators in the same category have equal precedence.
 
		
			
		
		Expand table
	
    
        Category
        Expression
        Description
    
    
        Primary
        i@i
        Identifier expression
    
    
        (x)
        Parenthesized expression
    
    
        x[i]
        Lookup
    
    
        x{y}
        Item access
    
    
        x(...)
        Function invocation
    
    
        {x, y, ...}
        List initialization
    
    
        [ i = x, ... ]
        Record initialization
    
    
        ...
        Not implemented
    
    
        Unary
        +x
        Identity
    
    
        -x
        Negation
    
    
        not x
        Logical negation
    
    
        Metadata
        x meta y
        Associate metadata
    
    
        Multiplicative
        x * y
        Multiplication
    
    
        x / y
        Division
    
    
        Additive
        x + y
        Addition
    
    
        x - y
        Subtraction
    
    
        Relational
        x < y
        Less than
    
    
        x > y
        Greater than
    
    
        x <= y
        Less than or equal
    
    
        x >= y
        Greater than or equal
    
    
        Equality
        x = y
        Equal
    
    
        x <> y
        Not equal
    
    
        Type assertion
        x as y
        Is compatible nullable-primitive type or error
    
    
        Type conformance
        x is y
        Test if compatible nullable-primitive type
    
    
        Logical AND
        x and y
        Short-circuiting conjunction
    
    
        Logical OR
        x or y
        Short-circuiting disjunction
    
    
        Coalesce
        x ?? y
        Null coalescing operator
    
    
        
        
        
    

Operators and metadata
Every value has an associated record value that can carry additional information about the value. This record is referred to as the metadata record for a value. A metadata record can be associated with any kind of value, even null. The result of such an association is a new value with the given metadata.
A metadata record is just a regular record and can contain any fields and values that a regular record can, and itself has a metadata record. Associating a metadata record with a value is ""non-intrusive"". It does not change the value's behavior in evaluations except for those that explicitly inspect metadata records.
Every value has a default metadata record, even if one has not been specified. The default metadata record is empty. The following examples show accessing the metadata record of a text value using the Value.Metadata standard library function:
Value.Metadata( ""Mozart"" )   // []

Metadata records are generally not preserved when a value is used with an operator or function that constructs a new value. For example, if two text values are concatenated using the & operator, the metadata of the resulting text value is the empty record []. The following expressions are equivalent:
""Amadeus "" & (""Mozart"" meta [ Rating = 5 ])  
""Amadeus "" & ""Mozart""

The standard library functions Value.RemoveMetadata and Value.ReplaceMetadata can be used to remove all metadata from a value and to replace a value's metadata (rather than merge metadata into possibly existing metadata).
The only operator that returns results that carry metadata is the meta operator.
Structurally recursive operators
Values can be cyclic. For example:
let l = {0, @l} in l
// {0, {0, {0, ... }}}
[A={B}, B={A}]
// [A = {{ ... }}, B = {{ ... }}]

M handles cyclic values by keeping construction of records, lists, and tables lazy. An attempt to construct a cyclic value that does not benefit from interjected lazy structured values yields an error:
[A=B, B=A] 
// [A = Error.Record(""Expression.Error"", 
//         ""A cyclic reference was encountered during evaluation""), 
//  B = Error.Record(""Expression.Error"", 
//         ""A cyclic reference was encountered during evaluation""), 
// ]

Some operators in M are defined by structural recursion. For instance, equality of records and lists is defined by the conjoined equality of corresponding record fields and item lists, respectively.
For non-cyclic values, applying structural recursion yields a finite expansion of the value: shared nested values will be traversed repeatedly, but the process of recursion always terminates.
A cyclic value has an infinite expansion when applying structural recursion. The semantics of M makes no special accommodations for such infinite expansions—an attempt to compare cyclic values for equality, for instance, will typically run out of resources and terminate exceptionally.
Selection and Projection Operators
The selection and projection operators allow data to be extracted from list and record values.
Item Access
A value may be selected from a list or table based on its zero-based position within that list or table using an item-access-expression.
item-access-expression:
      item-selection
      optional-item-selection
item-selection:
      primary-expression  {  item-selector  }
optional-item-selection:
      primary-expression {  item-selector  } ?
item-selector:
      expression
The item-access-expression x{y} returns:

For a list x and a number y, the item of list x at position y. The first item of a list is considered to have an ordinal index of zero. If the requested position does not exist in the list, an error is raised.

For a table x and a number y, the row of table x at position y. The first row of a table is considered to have an ordinal index of zero. If the requested position does not exist in the table, an error is raised.

For a table x and a record y, the row of table x that matches the field values of record y for fields with field names that match corresponding table-column names. If there is no unique matching row in the table, an error is raised.


For example:
{""a"",""b"",""c""}{0}                        // ""a"" 
{1, [A=2], 3}{1}                        // [A=2] 
{true, false}{2}                        // error 
#table({""A"",""B""},{{0,1},{2,1}}){0}      // [A=0,B=1] 
#table({""A"",""B""},{{0,1},{2,1}}){[A=2]}  // [A=2,B=1]  
#table({""A"",""B""},{{0,1},{2,1}}){[B=3]}  // error 
#table({""A"",""B""},{{0,1},{2,1}}){[B=1]}  // error

The item-access-expression also supports the form x{y}?, which returns null when position (or match) y does not exist in list or table x. If there are multiple matches for y, an error is still raised.
For example:
{""a"",""b"",""c""}{0}?                       // ""a"" 
{1, [A=2], 3}{1}?                       // [A=2] 
{true, false}{2}?                       // null 
#table({""A"",""B""},{{0,1},{2,1}}){0}?     // [A=0,B=1] 
#table({""A"",""B""},{{0,1},{2,1}}){[A=2]}? // [A=2,B=1]  
#table({""A"",""B""},{{0,1},{2,1}}){[B=3]}? // null 
#table({""A"",""B""},{{0,1},{2,1}}){[B=1]}? // error

Item access does not force the evaluation of list or table items other than the one being accessed. For example:
{ error ""a"", 1, error ""c""}{1}  // 1 
{ error ""a"", error ""b""}{1}     // error ""b""

The following holds when the item access operator x{y} is evaluated:

Errors raised during the evaluation of expressions x or y are propagated.

The expression x produces a list or a table value.

The expression y produces a number value or, if x produces a table value, a record value.

If y produces a number value and the value of y is negative, an error with reason code ""Expression.Error"" is raised.

If y produces a number value and the value of y is greater than or equal to the count of x, an error with reason code ""Expression.Error"" is raised unless the optional operator form x{y}? is used, in which case the value null is returned.

If x produces a table value and y produces a record value and there are no matches for y in x, an error with reason code ""Expression.Error"" is raised unless the optional operator form x{y}? is used, in which case the value null is returned.

If x produces a table value and y produces a record value and there are multiple matches for y in x, an error with reason code ""Expression.Error"" is raised.


No items in x other than that at position y is evaluated during the process of item selection. (For streaming lists or tables, the items or rows preceding that at position y are skipped over, which may cause their evaluation, depending on the source of the list or table.)
Field Access
The field-access-expression is used to select a value from a record or to project a record or table to one with fewer fields or columns, respectively.
field-access-expression:
      field-selection
      implicit-target-field-selection
      projection
      implicit-target-projection
field-selection:
      primary-expression field-selector
field-selector:
      required-field-selector
      optional-field-selector
required-field-selector:
      [   field-name  ]
optional-field-selector:
      [   field-name  ] ?
field-name:
      generalized-identifier
      quoted-identifier
implicit-target-field-selection:
      field-selector
projection:
      primary-expression required-projection
      primary-expression optional-projection
required-projection:
      [ required-selector-list ]
optional-projection:
      [ required-selector-list ] ? required-selector-list:
      required-field-selector
      required-selector-list , required-field-selector
implicit-target-projection:
      required-projection
      optional-projection
The simplest form of field access is required field selection. It uses the operator x[y] to look up a field in a record by field name. If the field y does not exist in x, an error is raised. The form x[y]? is used to perform optional field selection, and returns null if the requested field does not exist in the record.
For example:
[A=1,B=2][B]       // 2 
[A=1,B=2][C]       // error 
[A=1,B=2][C]?      // null

Collective access of multiple fields is supported by the operators for required record projection and optional record projection. The operator x[[y1],[y2],...] projects the record to a new record with fewer fields (selected by y1, y2, ...). If a selected field does not exist, an error is raised. The operator x[[y1],[y2],...] projects the record to a new record with the fields selected by y1, y2, ...; if a field is missing, null is used instead.
For example:
[A=1,B=2][[B]]           // [B=2] 
[A=1,B=2][[C]]           // error 
[A=1,B=2][[B],[C]]?      // [B=2,C=null]

The forms [y] and [y]? are supported as a shorthand reference to the identifier _ (underscore). The following two expressions are equivalent:
[A]                 
_[A]

The following example illustrates the shorthand form of field access:
let _ = [A=1,B=2] in [A] //1

The form [[y1],[y2],...] and [[y1],[y2],...]? are also supported as a shorthand and the following two expressions are likewise equivalent:
[[A],[B]]                 
_[[A],[B]]

The shorthand form is particularly useful in combination with the each shorthand, a way to introduce a function of a single parameter named _ (for details, see Simplified declarations). Together, the two shorthands simplify common higher-order functional expressions:
List.Select( {[a=1, b=1], [a=2, b=4]}, each [a] = [b]) 
// {[a=1, b=1]}

The above expression is equivalent to the following more cryptic looking longhand:
List.Select( {[a=1, b=1], [a=2, b=4]}, (_) => _[a] = _[b]) 
// {[a=1, b=1]}

Field access does not force the evaluation of fields other than the one(s) being accessed. For example:
[A=error ""a"", B=1, C=error ""c""][B]  // 1 
[A=error ""a"", B=error ""b""][B]       // error ""b""

The following holds when a field access operator x[y], x[y]?, x[[y]], or x[[y]]? is evaluated:

Errors raised during the evaluation of expression x are propagated.

Errors raised when evaluating field y are permanently associated with field y, then propagated. Any future access to field y will raise the identical error.

The expression x produces a record or table value, or an error is raised.

If the identifier y names a field that does not exist in x, an error with reason code ""Expression.Error"" is raised unless the optional operator form ...? is used, in which case the value null is returned.


No fields of x other than that named by y is evaluated during the process of field access.
Metadata operator
The metadata record for a value is amended using the meta operator (x meta y).
metadata-expression:
      unary-expression
      unary-expression  meta  unary-expression
The following example constructs a text value with a metadata record using the meta operator and then accesses the metadata record of the resulting value using Value.Metadata:
Value.Metadata( ""Mozart"" meta [ Rating = 5 ] ) 
// [Rating = 5 ]
Value.Metadata( ""Mozart"" meta [ Rating = 5 ] )[Rating] 
// 5

The following holds when applying the metadata combining operator x meta y:

Errors raised when evaluating the x or y expressions are propagated.

The y expression must be a record, or an error with reason code ""Expression.Error"" is raised.

The resulting metadata record is x's metadata record merged with y. (For the semantics of record merge, see Record merge.)

The resulting value is the value from the x expression, without its metadata, with the newly computed metadata record attached.


The standard library functions Value.RemoveMetadata and Value.ReplaceMetadata can be used to remove all metadata from a value and to replace a value's metadata (rather than merge metadata into possibly existing metadata). The following expressions are equivalent:
x meta y  
Value.ReplaceMetadata(x, Value.Metadata(x) & y) 
Value.RemoveMetadata(x) meta (Value.Metadata(x) & y)

Equality operators
The equality operator = is used to determine if two values are equal. The inequality operator <> is used to determine if two values are not equal.
equality-expression:
      relational-expression
      relational-expression  =  equality-expression
      relational-expression  <>  equality-expression
For example:
1 = 1            // true 
1 = 2            // false 
1 <> 1           // false 
1 <> 2           // true 
null = true      // false 
null = null      // true

Metadata is not part of equality or inequality comparison. For example:
(1 meta [ a = 1 ]) = (1 meta [ a = 2 ]) // true 
(1 meta [ a = 1 ]) = 1                  // true

The following holds when applying the equality operators x = y and x <> y:

Errors raised when evaluating the x or y expressions are propagated.

The =  operator has a result of true if the values are equal, and false otherwise.

The <> operator has a result of false if the values are equal, and true otherwise.

Metadata records are not included in the comparison.

If values produced by evaluating the x and y expressions are not the same kind of value, then the values are not equal.

If the values produced by evaluating the x and y expression are the same kind of value, then there are specific rules for determining if they are equal, as defined below.

The following is always true:


    (x = y) = not (x <> y)

The equality operators are defined for the following types:

The null value is only equal to itself.

    null = null    // true 
    null = true    // false 
    null = false   // false


The logical values true and false are only equal to themselves. For example:

    true = true      // true 
    false = false    // true 
    true = false     // false 
    true = 1         // false


Numbers are compared using the specified precision:

If either number is #nan, then the numbers are not the same.

When neither number is #nan, then the numbers are compared using a bit-wise comparison of the numeric value.

#nan is the only value that is not equal to itself.
For example:




        1 = 1,              // true 
        1.0 = 1             // true 
        2 = 1               // false 
        #nan = #nan         // false 
        #nan <> #nan        // true


Two durations are equal if they represent the same number of 100-nanosecond ticks.

Two times are equal if the magnitudes of their parts (hour, minute, second) are equal.

Two dates are equal if the magnitudes of their parts (year, month, day) are equal.

Two datetimes are equal if the magnitudes of their parts (year, month, day, hour, minute, second) are equal.

Two datetimezones are equal if the corresponding UTC datetimes are equal. To arrive at the corresponding UTC datetime, the hours/minutes offset is subtracted from the datetime component of the datetimezone.

Two text values are equal if using an ordinal, case-sensitive, culture-insensitive comparison they have the same length and equal characters at corresponding positions.

Two list values are equal if all of the following are true:

Both lists contain the same number of items.

The values of each positionally corresponding item in the lists are equal. This means that not only do the lists need to contain equal items, the items need to be in the same order.
For example:
  {1, 2} = {1, 2}     // true 
  {2, 1} = {1, 2}     // false 
  {1, 2, 3} = {1, 2}  // false




Two records are equal if all of the following are true:

The number of fields is the same.

Each field name of one record is also present in the other record.

The value of each field of one record is equal to the like-named field in the other record.
For example:
  [ A = 1, B = 2 ] = [ A = 1, B = 2 ]        // true 
  [ B = 2, A = 1 ] = [ A = 1, B = 2 ]        // true 
  [ A = 1, B = 2, C = 3 ] = [ A = 1, B = 2 ] // false 
  [ A = 1 ] = [ A = 1, B = 2 ]               // false




Two tables are equal if all of the following are true:

The number of columns is the same.

Each column name in one table is also present in the other table.

The number of rows is the same.

Each row has equal values in corresponding cells.
For example:
  #table({""A"",""B""},{{1,2}}) = #table({""A"",""B""},{{1,2}}) // true 
  #table({""A"",""B""},{{1,2}}) = #table({""X"",""Y""},{{1,2}}) // false 
  #table({""A"",""B""},{{1,2}}) = #table({""B"",""A""},{{2,1}}) // true




A function value is equal to itself, but may or may not be equal to another function value. If two function values are considered equal, then they will behave identically when invoked.
Two given function values will always have the same equality relationship.

A type value is equal to itself, but may or may not be equal to another type value. If two type values are considered equal, then they will behave identically when queried for conformance.
Two given type values will always have the same equality relationship.


Relational operators
The <, >, <=, and >= operators are called the relational operators.
relational-expression:
      additive-expression
      additive-expression  <  relational-expression
      additive-expression  >  relational-expression
      additive-expression  <=  relational-expression
      additive-expression  >=  relational-expression
These operators are used to determine the relative ordering relationship between two values, as shown in the following table:
 
		
			
		
		Expand table
	


Operation
Result




x < y
true if x is less than y, false otherwise


x > y
true if x is greater than y, false otherwise


x <= y
true if x is less than or equal to y, false otherwise


x >= y
true if x is greater than or equal to y, false otherwise



For example:
0 <= 1            // true 
null < 1          // null 
null <= null      // null 
""ab"" < ""abc""      // true 
#nan >= #nan      // false  
#nan <= #nan      // false

The following holds when evaluating an expression containing the relational operators:

Errors raised when evaluating the x or y operand expressions are propagated.

The values produced by evaluating both the x and y expressions must be a binary, date, datetime, datetimezone, duration, logical, number, null, text or time value. Otherwise, an error with reason code ""Expression.Error"" is raised.

Both operands must be the same kind of value or null. Otherwise, an error with reason code ""Expression.Error"" is raised.

If either or both operands are null, the result is the null value.

Two binaries are compared byte by byte.

Two dates are compared by comparing their year parts and, if equal, their month parts and, if equal, their day parts.

Two datetimes are compared by comparing their year parts and, if equal, their month parts and, if equal, their day parts and, if equal, their hour parts and, if equal, their minute parts and, if equal, their second parts.

Two datetimezones are compared by normalizing them to UTC by subtracting their hour/minute offset and then comparing their datetime components.

Two durations are compared according to the total number of 100-nanosecond ticks they represent.

Two logicals are compared such that  true is considered to be greater than false.

Two numbers x and y are compared according to the rules of the IEEE 754 standard:

If either operand is #nan, the result is false for all relational operators.

When neither operand is #nan, the operators compare the values of the two floatingpoint operands with respect to the ordering -∞ < -max < ... < -min < -0.0 = +0.0 < +min < ... < +max < +∞ where min and max are the smallest and largest positive finite values that can be represented. The M names for -∞ and +∞ are -#infinity and #infinity.
Notable effects of this ordering are:

Negative and positive zeros are considered equal.

A -#infinity value is considered less than all other number values, but equal to another -#infinity.

A #infinity value is considered greater than all other number values, but equal to another #infinity.





Two texts are compared by using a character-by-character ordinal, case-sensitive, culture-insensitive comparison.

Two times are compared by comparing their hour parts and, if equal, their minute parts and, if equal, their second parts.


Conditional logical operators
The and and or operators are called the conditional logical operators.
logical-or-expression:
      logical-and-expression
      logical-and-expression  or  logical-or-expression
logical-and-expression:
      is-expression
      is-expression  and  logical-and-expression
The or operator returns true when at least one of its operands is true. The right operand is evaluated if and only if the left operand is not true.
The and operator returns false when at least one of its operands is false. The right operand is evaluated if and only if the left operand is not false.
Truth tables for the or and and operators are shown below, with the result of evaluating the left operand expression on the vertical axis and the result of evaluating the right operand expression on the horizontal axis.
 
		
			
		
		Expand table
	


and
true
false
null
error




true
true
false
null
error


false
false
false
false
false


null
null
false
null
error


error
error
error
error
error



 
		
			
		
		Expand table
	


or
true
false
null
error




or
true
false
null
error


true
true
true
true
true


false
true
false
null
error


null
true
null
null
error


error
error
error
error
error



The following holds when evaluating an expression containing conditional logical operators:

Errors raised when evaluating the x or y expressions are propagated.

The conditional logical operators are defined over the types logical and null. If the operand values are not of those types, an error with reason code ""Expression.Error"" is raised.

The result is a logical value.

In the expression x or y, the expression y will be evaluated if and only if x does not evaluate to true.

In the expression x and y, the expression y will be evaluated if and only if x does not evaluate to false.


The last two properties give the conditional logical operators their ""conditional"" qualification; properties also referred to as ""short-circuiting"". These properties are useful to write compact guarded predicates. For example, the following expressions are equivalent:
d <> 0 and n/d > 1 if d <> 0 then n/d > 1 else false

Arithmetic Operators
The +, -, * and / operators are the arithmetic operators.
additive-expression:
      multiplicative-expression
      additive-expression  +  multiplicative-expression
      additive-expression  -  multiplicative-expression
multiplicative-expression:
      metadata- expression
      multiplicative-expression  *  metadata-expression
      multiplicative-expression  /  metadata-expression
Precision
Numbers in M are stored using a variety of representations to retain as much information as possible about numbers coming from a variety of sources. Numbers are only converted from one representation to another as needed by operators applied to them. Two precisions are supported in M:
 
		
			
		
		Expand table
	


Precision
Semantics




Precision.Decimal
128-bit decimal representation with a range of ±1.0 x 10-28 to ±7.9 x 1028 and 28-29 significant digits.


Precision.Double
Scientific representation using mantissa and exponent; conforms to the 64-bit binary double-precision IEEE 754 arithmetic standard IEEE 754-2008.



Arithmetic operations are performed by choosing a precision, converting both operands to that precision (if necessary), then performing the actual operation, and finally returning a number in the chosen precision.
The built-in arithmetic operators (+, -, *, /) use Double Precision. Standard library functions (Value.Add, Value.Subtract, Value.Multiply, Value.Divide) can be used to request these operations using a specific precision model.

No numeric overflow is possible: #infinity or -#infinity represent values of magnitudes too large to be represented.

No numeric underflow is possible: 0 and -0 represent values of magnitudes too small to be represented.

The IEEE 754 special value #nan (NaN—Not a Number) is used to cover arithmetically invalid cases, such as a division of zero by zero.

Conversion from Decimal to Double precision is performed by rounding decimal numbers to the nearest equivalent double value.

Conversion from Double to Decimal precision is performed by rounding double numbers to the nearest equivalent decimal value and, if necessary, overflowing to #infinity or -#infinity values.


Addition operator
The interpretation of the addition operator (x + y) is dependent on the kind of value of the evaluated expressions x and y, as follows:
 
		
			
		
		Expand table
	


x
y
Result
Interpretation




type number
type number
type number
Numeric sum


type number
null
null



null
type number
null



type duration
type duration
type duration
Numeric sum of magnitudes


type duration
null
null



null
type duration
null



type datetime
type duration
type datetime
Datetime offset by duration


type duration
type datetime
type datetime



type datetime
null
null



null
type datetime
null




In the table, type datetime stands for any of type date, type datetime, type datetimezone, or type time. When adding a duration and a value of some type datetime, the resulting value is of that same type.
For other combinations of values than those listed in the table, an error with reason code ""Expression.Error"" is raised. Each combination is covered in the following sections.
Errors raised when evaluating either operand are propagated.
Numeric sum
The sum of two numbers is computed using the addition operator, producing a number.
For example:
1 + 1             // 2 
#nan + #infinity  // #nan

The addition operator + over numbers uses Double Precision; the standard library function Value.Add can be used to specify Decimal Precision. The following holds when computing a sum of numbers:

The sum in Double Precision is computed according to the rules of 64-bit binary doubleprecision IEEE 754 arithmetic IEEE 754-2008. The following table lists the results of all possible combinations of nonzero finite values, zeros, infinities, and NaN's. In the table, x and y are nonzero finite values, and z is the result of x + y. If x and y have the same magnitude but opposite signs, z is positive zero. If x + y is too large to be represented in the destination type, z is an infinity with the same sign as x + y.
 
		
			
		
		Expand table
	


+
y
+0
-0
+∞
-∞
NaN




x
z
x
x
+∞
-∞
NaN


+0
y
+0
+0
+∞
-∞
NaN


-0
y
+0
-0
+∞
-∞
NaN


+∞
+∞
+∞
+∞
+∞
NaN
NaN


-∞
-∞
-∞
-∞
NaN
-∞
NaN


NaN
NaN
NaN
NaN
NaN
NaN
NaN




The sum in Decimal Precision is computed without losing precision. The scale of the result is the larger of the scales of the two operands.


Sum of durations
The sum of two durations is the duration representing the sum of the number of 100nanosecond ticks represented by the durations. For example:
#duration(2,1,0,15.1) + #duration(0,1,30,45.3) 
// #duration(2, 2, 31, 0.4)

Datetime offset by duration
A datetime x and a duration y may be added using x + y to compute a new datetime whose distance from x on a linear timeline is exactly the magnitude of y. Here, datetime stands for any of Date, DateTime, DateTimeZone, or Time and a non-null result will be of the same type. The datetime offset by duration may be computed as follows:

If the datetime's days since epoch value is specified, construct a new datetime with the following information elements:

Calculate a new days since epoch equivalent to dividing the magnitude of y by the number of 100-nanosecond ticks in a 24-hour period, truncating the decimal portion of the result, and adding this value to the x's days since epoch.

Calculate a new ticks since midnight equivalent to adding the magnitude of y to the x's ticks since midnight, modulo the number of 100-nanosecond ticks in a 24-hour period. If x does not specify a value for ticks since midnight, a value of 0 is assumed.

Copy x's value for minutes offset from UTC unchanged.



If the datetime's days since epoch value is unspecified, construct a new datetime with the following information elements specified:

Calculate a new ticks since midnight equivalent to adding the magnitude of y to the x's ticks since midnight, modulo the number of 100-nanosecond ticks in a 24-hour period. If x does not specify a value for ticks since midnight, a value of 0 is assumed.

Copy x's values for days since epoch and minutes offset from UTC unchanged.




The following examples show calculating the absolute temporal sum when the datetime specifies the days since epoch:
#date(2010,05,20) + #duration(0,8,0,0) 
    //#datetime( 2010, 5, 20, 8, 0, 0 ) 
    //2010-05-20T08:00:00 
 
#date(2010,01,31) + #duration(30,08,0,0) 
    //#datetime(2010, 3, 2, 8, 0, 0) 
    //2010-03-02T08:00:00 
 
#datetime(2010,05,20,12,00,00,-08) + #duration(0,04,30,00) 
    //#datetime(2010, 5, 20, 16, 30, 0, -8, 0) 
    //2010-05-20T16:30:00-08:00 
 
#datetime(2010,10,10,0,0,0,0) + #duration(1,0,0,0) 
   //#datetime(2010, 10, 11, 0, 0, 0, 0, 0) 
   //2010-10-11T00:00:00+00:00

The following example shows calculating the datetime offset by duration for a given time:
#time(8,0,0) + #duration(30,5,0,0) 
   //#time(13, 0, 0) 
   //13:00:00

Subtraction operator
The interpretation of the subtraction operator (x - y) is dependent on the kind of the value of the evaluated expressions x and y, as follows:
 
		
			
		
		Expand table
	


x
Y
Result
"
Let,https://learn.microsoft.com/en-us/powerquery-m/m-spec-let,"Let
										
											Article10/10/2022
															
															2 contributors
														
										

	
		
			
		
		Feedback
	

											In this article
										Let expression
A let expression can be used to capture a value from an intermediate calculation in a variable.
let-expression:
      let variable-list in expression
variable-list:
      variable
      variable , variable-list
variable:
      variable-name = expression
variable-name:
      identifier
The following example shows intermediate results being calculated and stored in variables x, y, and z which are then used in a subsequent calculation x + y + z:
let     x = 1 + 1,
        y = 2 + 2,
        z = y + 1 
in
        x + y + z

The result of this expression is:
11  // (1 + 1) + (2 + 2) + (2 + 2 + 1)

The following holds when evaluating expressions within the let-expression:

The expressions in the variable list define a new scope containing the identifiers from the variable-list production and must be present when evaluating the expressions within the variable-list productions. Expressions within the variable-list may refer to one-another.

The expressions within the variable-list must be evaluated before the expression in the let-expression is evaluated.

Unless the expressions in the variable-list are accessed, they must not be evaluated.

Errors that are raised during the evaluation of the expressions in the let-expression are propagated.


A let expression can be seen as syntactic sugar over an implicit record expression. The following expression is equivalent to the example above:
[     x = 1 + 1,
      y = 2 + 2,
      z = y + 1,
      result = x + y + z 
][result]"
Conditionals,https://learn.microsoft.com/en-us/powerquery-m/m-spec-conditionals,"Conditionals
										
											Article03/29/2024
															
															3 contributors
														
										

	
		
			
		
		Feedback
	

											In this article
										The if-expression selects from two expressions based on the value of a logical input value and evaluates only the selected expression.
if-expression:
       if  if-condition  then  true-expression  else  false-expression
if-condition:
      expression
true-expression:
      expression
false-expression:
      expression
The following are examples of if-expressions:
if 2 > 1 then 2 else 1          // 2
if 1 = 1 then ""yes"" else ""no""   // ""yes""

The following holds when evaluating an if-expression:

If the value produced by evaluating the if-condition is not a logical value, then an error with reason code ""Expression.Error"" is raised.

The true-expression is only evaluated if the if-condition evaluates to the value true.

The false-expression is only evaluated if the if-condition evaluates to the value false.

The result of the if-expression is the value of the true-expression if the if-condition is true, and the value of the false-expression if the if-condition is false.

Errors raised during the evaluation of the if-condition, true-expression, or false-expression are propagated."
Functions,https://learn.microsoft.com/en-us/powerquery-m/m-spec-functions,"Functions
										
											Article07/07/2023
															
															3 contributors
														
										

	
		
			
		
		Feedback
	
 
		In this article
		
			
					
						Writing functions
					
				
					
						Invoking functions
					
				
					
						Parameters
					
				
					
						Recursive functions
					
				
					
						Closures
					
				
					
						Functions and environments
					
				
					
						Simplified declarations
					
				
		
	 
		
			Show 3 more
			
		
	 A function is a value that represents a mapping from a set of argument values to a single value. A function is invoked by provided a set of input values (the argument values), and produces a single output value (the return value).
Writing functions
Functions are written using a function-expression:
function-expression:
      (  parameter-listopt  )  function-return-typeopt  =>  function-body
function-body:
      expression
parameter-list:
      fixed-parameter-list
      fixed-parameter-list  ,  optional-parameter-list
      optional-parameter-list
fixed-parameter-list:
      parameter
      parameter  ,  fixed-parameter-list
parameter:
      parameter-name parameter-typeopt
parameter-name:
      identifier
parameter-type:
      assertion
function-return-type:
      assertion
assertion:
      as  nullable-primiitve-type
optional-parameter-list:
      optional-parameter
      optional-parameter  ,  optional-parameter-list
optional-parameter:
      optional parameter
nullable-primitve-type
      nullableopt primitive-type
The following is an example of a function that requires exactly two values x and y, and produces the result of applying the + operator to those values. The x and y are parameters that are part of the parameter-list of the function, and the x + y is the function-body:
(x, y) => x + y

The result of evaluating a function-expression is to produce a function value (not to evaluate the function-body). As a convention in this document, function values (as opposed to function expressions) are shown with the parameter-list but with an ellipsis (...) instead of the function-body. For example, once the function expression above has been evaluated, it would be shown as the following function value:
 (x, y) => ...

The following operators are defined for function values:
 
		
			
		
		Expand table
	


Operator
Result




x = y
Equal


x <> y
Not equal



The native type of function values is a custom function type (derived from the intrinsic type function) that lists the parameter names and specifies all parameter types and the return type to be any. (Go to Function types for details on function types.)
Invoking functions
The function-body of a function is executed by invoking the function value using an invoke-expression. Invoking a function value means the function-body of the function value is evaluated and a value is returned or an error is raised.
invoke-expression:
      primary-expression  (  argument-listopt  )
argument-list:
      expression-list
Each time a function value is invoked, a set of values are specified as an argument-list, called the arguments to the function.
An argument-list is used to specify a fixed number of arguments directly as a list of expressions. The following example defines a record with a function value in a field, and then invokes the function from another field of the record:
[ 
    MyFunction = (x, y, z) => x + y + z, 
    Result1 = MyFunction(1, 2, 3)           // 6
]

The following holds when invoking a function:

The environment used to evaluate the function-body of the function includes a variable that corresponds to each parameter, with the same name as the parameter. The value of each parameter corresponds to a value constructed from the argument-list of the invoke-expression, as defined in Parameters.

All of the expressions corresponding to the function arguments are evaluated before the function-body is evaluated.

Errors raised when evaluating the expressions in the expression-list or function-body are propagated.

The number of arguments constructed from the argument-list must be compatible with the parameters of the function, or an error is raised with reason code ""Expression.Error"". The process for determining compatibility is defined in Parameters.


Parameters
There are two kinds of parameters that may be present in a parameter-list:

A required parameter indicates that an argument corresponding to the parameter must always be specified when a function is invoked. Required parameters must be specified first in the parameter-list. The function in the following example defines required parameters x and y:
  [ 
      MyFunction = (x, y) => x + y, 

      Result1 = MyFunction(1, 1),     // 2 
      Result2 = MyFunction(2, 2)      // 4
  ] 


An optional parameter indicates that an argument corresponding to the parameter may be specified when a function is invoked, but is not required to be specified. If an argument that corresponds to an optional parameter is not specified when the function is invoked, then the value null is used instead. Optional parameters must appear after any required parameters in a parameter-list. The function in the following example defines a fixed parameter x and an optional parameter y:
  [ 
      MyFunction = (x, optional y) =>
                        if (y = null) x else x + y, 
      Result1 = MyFunction(1),        // 1 
      Result2 = MyFunction(1, null),  // 1 
      Result3 = MyFunction(2, 2),     // 4
  ] 



The number of arguments that are specified when a function is invoked must be compatible with the parameter list. Compatibility of a set of arguments A for a function F is computed as follows:

Let the value N represent the number of arguments A constructed from the argument-list. For example:
  MyFunction()             // N = 0 
  MyFunction(1)            // N = 1 
  MyFunction(null)         // N = 1 
  MyFunction(null, 2)      // N = 2 
  MyFunction(1, 2, 3)      // N = 3 
  MyFunction(1, 2, null)   // N = 3 
  MyFunction(1, 2, {3, 4}) // N = 3


Let the value Required represent the number of fixed parameters of F and Optional the number of optional parameters of F. For example:
()               // Required = 0, Optional = 0 
(x)              // Required = 1, Optional = 0 
(optional x)     // Required = 0, Optional = 1 
(x, optional y)  // Required = 1, Optional = 1


Arguments A are compatible with function F if the following are true:

(N >= Fixed) and (N <= (Fixed + Optional))
The argument types are compatible with F's corresponding parameter types


If the function has a declared return type, then the result value of the body of function F is compatible with F's return type if the following is true:

The value yielded by evaluating the function body with the supplied arguments for the function parameters has a type that is compatible with the return type.


If the function body yields a value incompatible with the function's return type, an error with reason code ""Expression.Error"" is raised.


Recursive functions
In order to write a function value that is recursive, it is necessary to use the scoping operator (@) to reference the function within its scope. For example, the following record contains a field that defines the Factorial function, and another field that invokes it:
[ 
    Factorial = (x) => 
                if x = 0 then 1 else x * @Factorial(x - 1), 
    Result = Factorial(3)  // 6 
]

Similarly, mutually recursive functions can be written as long as each function that needs to be accessed has a name. In the following example, part of the Factorial function has been refactored into a second Factorial2 function.
[ 
    Factorial = (x) => if x = 0 then 1 else Factorial2(x), 
    Factorial2 = (x) => x * Factorial(x - 1), 
    Result = Factorial(3)     // 6 
]

Closures
A function can return another function as a value. This function can in turn depend on one or more parameters to the original function. In the following example, the function associated with the field MyFunction returns a function that returns the parameter specified to it:
[ 
    MyFunction = (x) => () => x, 
    MyFunction1 = MyFunction(1), 
    MyFunction2 = MyFunction(2), 
    Result = MyFunction1() + MyFunction2()  // 3 
]

Each time the function is invoked, a new function value will be returned that maintains the value of the parameter so that when it is invoked, the parameter value will be returned.
Functions and environments
In addition to parameters, the function-body of a function-expression can reference variables that are present in the environment when the function is initialized. For example, the function defined by the field MyFunction accesses the field C of the enclosing record A:
[ 
A =  
    [ 
        MyFunction = () => C, 
        C = 1 
    ], 
B = A[MyFunction]()           // 1 
]

When MyFunction is invoked, it accesses the value of the variable C, even though it is being invoked from an environment (B) that does not contain a variable C.
Simplified declarations
The each-expression is a syntactic shorthand for declaring untyped functions taking a single parameter named _ (underscore).
each-expression:
      each each-expression-body
each-expression-body:
      function-body
Simplified declarations are commonly used to improve the readability of higher-order function invocation.
For example, the following pairs of declarations are semantically equivalent:
each _ + 1 
(_) => _ + 1  
each [A] 
(_) => _[A] 
 
Table.SelectRows( aTable, each [Weight] > 12 ) 
Table.SelectRows( aTable, (_) => _[Weight] > 12 )"
Error Handling,https://learn.microsoft.com/en-us/powerquery-m/m-spec-error-handling,"Error Handling
										
											Article03/07/2023
															
															3 contributors
														
										

	
		
			
		
		Feedback
	

		In this article
		
			
					
						Raising errors
					
				
					
						Handling errors
					
				
					
						Errors in record and let initializers
					
				
					
						Not implemented error
					
				
		
	The result of evaluating an M expression produces one of the following outcomes:

A single value is produced.

An error is raised, indicating the process of evaluating the expression could not produce a value. An error contains a single record value that can be used to provide additional information about what caused the incomplete evaluation.


Errors can be raised from within an expression, and can be handled from within an expression.
Raising errors
The syntax for raising an error is as follows:
error-raising-expression:
      error  expression
Text values can be used as shorthand for error values. For example:
error ""Hello, world"" // error with message ""Hello, world""

Full error values are records and can be constructed using the Error.Record function:
error Error.Record(""FileNotFound"", ""File my.txt not found"",
     ""my.txt"")

The above expression is equivalent to:
error [ 
    Reason = ""FileNotFound"", 
    Message = ""File my.txt not found"", 
    Detail = ""my.txt"" 
]

Raising an error will cause the current expression evaluation to stop, and the expression evaluation stack will unwind until one of the following occurs:

A record field, section member, or let variable—collectively: an entry—is reached. The entry is marked as having an error, the error value is saved with that entry, and then propagated. Any subsequent access to that entry will cause an identical error to be raised. Other entries of the record, section, or let expression are not necessarily affected (unless they access an entry previously marked as having an error).

The top-level expression is reached. In this case, the result of evaluating the top-level expression is an error instead of a value.

A try expression is reached. In this case, the error is captured and returned as a value.


Handling errors
An error-handling-expression (informally known as a ""try expression"") is used to handle an error:
error-handling-expression:
      try protected-expression
error-handleropt
protected-expression:
      expression
error-handler:
      otherwise-clause
      catch-clause
otherwise-clause:
      otherwise default-expression
default-expression:
      expression
catch-clause:
      catch catch-function
catch-function:
      (parameter-nameopt) => function-body
The following holds when evaluating an error-handling-expression without an error-handler:

If the evaluation of the protected-expression does not result in an error and produces a value x, the value produced by the error-handling-expression is a record of the following form:

    [ HasErrors = false, Value = x ]


If the evaluation of the protected-expression raises an error value e, the result of the error-handling-expression is a record of the following form:

    [ HasErrors = true, Error = e ]

The following holds when evaluating an error-handling-expression with an error-handler:

The protected-expression must be evaluated before the error-handler.

The error-handler must be evaluated if and only if the evaluation of the protected-expression raises an error.

If the evaluation of the protected-expression raises an error, the value produced by the error-handling-expression is the result of evaluating the error-handler.

Errors raised during the evaluation of the error-handler are propagated.

When the error-handler being evaluated is a catch-clause, the  catch-function is invoked. If that function accepts a parameter, the error value will be passed as its value.


The following example illustrates an error-handling-expression in a case where no error is raised:
let
    x = try ""A""
in
    if x[HasError] then x[Error] else x[Value] 
// ""A""

The following example shows raising an error and then handling it:
let
    x = try error ""A"" 
in
    if x[HasError] then x[Error] else x[Value] 
// [ Reason = ""Expression.Error"", Message = ""A"", Detail = null ]

The preceding example can be rewritten with less syntax by using a catch-clause with a catch-function that accepts a parameter:
let
    x = try error ""A"" catch (e) => e
in
    x
// [ Reason = ""Expression.Error"", Message = ""A"", Detail = null ]

An otherwise-clause can be used to replace errors handled by a try expression with an alternative value:
try error ""A"" otherwise 1 
// 1

A catch-clause with a zero-parameter catch-function is effectively a longer, alternative syntax for an otherwise-clause:
try error ""A"" catch () => 1 
// 1

If the error-handler also raises an error, then so does the entire try expression:
try error ""A"" otherwise error ""B"" 
// error with message ""B""

try error ""A"" catch () => error ""B"" 
// error with message ""B""

try error ""A"" catch (e) => error ""B"" 
// error with message ""B""

Errors in record and let initializers
The following example shows a record initializer with a field A that raises an error and is accessed by two other fields B and C. Field B does not handle the error that is raised by A, but C does. The final field D does not access A and so it is not affected by the error in A.
[ 
    A = error ""A"", 
    B = A + 1,
    C = let x =
            try A in
                if not x[HasError] then x[Value]
                else x[Error], 
    D = 1 + 1 
]

The result of evaluating the above expression is:
[ 
    A = // error with message ""A"" 
    B = // error with message ""A"" 
    C = ""A"", 
    D = 2 
]

Error handling in M should be performed close to the cause of errors to deal with the effects of lazy field initialization and deferred closure evaluations. The following example shows an unsuccessful attempt at handling an error using a try expression:
let
    f = (x) => [ a = error ""bad"", b = x ],
    g = try f(42) otherwise 123
in 
    g[a]  // error ""bad""

In this example, the definition g was meant to handle the error raised when calling f. However, the error is raised by a field initializer that only runs when needed and thus after the record was returned from f and passed through the try expression.
Not implemented error
While an expression is being developed, an author may want to leave out the implementation for some parts of the expression, but may still want to be able to execute the expression. One way to handle this case is to raise an error for the unimplemented parts. For example:
(x, y) =>
     if x > y then
         x - y
     else
         error Error.Record(""Expression.Error"", 
            ""Not Implemented"")

The ellipsis symbol (...) can be used as a shortcut for error.
not-implemented-expression:
      ...
For example, the following is equivalent to the previous example:
(x, y) => if x > y then x - y else ..."
Sections,https://learn.microsoft.com/en-us/powerquery-m/m-spec-sections,"Sections
										
											Article10/10/2022
															
															4 contributors
														
										

	
		
			
		
		Feedback
	

		In this article
		
			
					
						Document Linking
					
				
					
						Document Introspection
					
				
		
	A section-document is an M program that consists of multiple named expressions.
section-document:
      section
section:
      literal-attributesopt  section  section-name  ;  section-membersopt
section-name:
      identifier
section-members:
      section-member section-membersopt
section-member:
      literal-attributesopt  sharedopt section-member-name  =  expression  ;
section-member-name:
      identifier
In M, a section is an organizational concept that allows related expressions to be named and grouped within a document. Each section has a section-name, which identifies the section and qualifies the names of the section-members declared within the section. A section-member consists of a member-name and an expression. Section member expressions may refer to other section members within the same section directly by member name.
The following example shows a section-document:
section Section1; 

A = 1;                          //1
B = 2;                          //2 
C = A + B;                      //3

Section member expressions may refer to section members located in other sections by means of a section-access-expression, which qualifies a section member name with the name of the containing section.
section-access-expression:
      identifier ! identifier
The following example shows a set of two documents containing sections that are mutually referential:
section Section1; 
A = ""Hello"";                    //""Hello"" 
B = 1 + Section2!A;             //3

section Section2; 
A = 2;                          //2 
B = Section1!A & "" world!"";     //""Hello, world""

Section members may optionally be declared as shared, which omits the requirement to use a section-access-expression when referring to shared members outside of the containing section. Shared members in external sections may be referred to by their unqualified member name so long as no member of the same name is declared in the referring section and no other section has a like-named shared member.
The following example illustrates the behavior of shared members when used across sections within the same set of documents:
section Section1;  
shared A = 1;        // 1 

section Section2; 
B = A + 2;           // 3 (refers to shared A from Section1) 

section Section3; 
A = ""Hello"";         // ""Hello"" 
B = A + "" world"";    // ""Hello world"" (refers to local A) 
C = Section1!A + 2;  // 3

Defining a shared member with the same name in different sections will produce a valid global environment, however accessing the shared member will raise an error when accessed.
section Section1; 
shared A = 1; 

section Section2; 
shared A = ""Hello""; 
 
section Section3; 
B = A;    //Error: shared member A has multiple definitions

The following holds when evaluating a set of section-documents:

Each section-name must be unique in the global environment.

Within a section, each section-member must have a unique section-member-name.

Shared section members with more than one definition raise an error when the shared member is accessed.

The expression component of a section-member must not be evaluated before the section member is accessed.

Errors raised while the expression component of a section-member is evaluated are associated with that section member before propagating outward and then re-raised each time the section member is accessed.


Document Linking
A set of M section documents can be linked into an opaque record value that has one field per shared member of the section documents. If shared members have ambiguous names, an error is raised.
The resulting record value fully closes over the global environment in which the link process was performed. Such records are, therefore, suitable components to compose M documents from other (linked) sets of M documents. There are no opportunities for naming conflicts.
The standard library functions Embedded.Value can be used to retrieve such ""embedded"" record values that correspond to reused M components.
Document Introspection
M provides programmatic access to the global environment by means of the #sections and #shared keywords.
#sections
The #sections intrinsic variable returns all sections within the global environment as a record. This record is keyed by section name and each value is a record representation of the corresponding section indexed by section member name.
The following example shows a document consisting of two sections and the record produced by evaluating the #sections intrinsic variable within the context of that document:
section Section1; 
A = 1; 
B = 2;  

section Section2;
C = ""Hello""; 
D = ""world""; 
 
#sections 
//[ 
//  Section1 = [ A = 1, B = 2], 
//  Section2 = [ C = ""Hello"", D = ""world"" ] 
//] 

The following holds when evaluating #sections:

The #sections intrinsic variable preserves the evaluation state of all section member expressions within the document.
The #sections intrinsic variable does not force the evaluation of any unevaluated section members.

#shared
The #shared intrinsic variable returns the contents of the global environment as a record. (The global environment consists of all shared section members as well as any identifiers directly included in the global environment by the expression evaluator.) This record is keyed by identifier name, with each value being the value of the associated identifier.
The following example shows a document with two shared members and the corresponding record produced by evaluating the #shared intrinsic variable within the context of that document:
section Section1;
shared A = 1; 
B = 2; 
 
Section Section2;
C = ""Hello"";
shared D = ""world""; 
 
//[ 
//  A = 1, 
//  D = ""world"" 
//] 

The following holds when evaluating #shared:

The #shared intrinsic variable preserves the evaluation state of the global environment.

The #shared intrinsic variable does not force the evaluation of any unevaluated value."
Consolidated Grammar,https://learn.microsoft.com/en-us/powerquery-m/m-spec-consolidated-grammar,"Consolidated Grammar
										
											Article02/02/2024
															
															5 contributors
														
										

	
		
			
		
		Feedback
	

		In this article
		
			
					
						Lexical grammar
					
				
					
						Syntactic grammar
					
				
		
	Lexical grammar
lexical-unit:
      lexical-elementsopt
lexical-elements:
      lexical-element lexical-elementsopt
lexical-element:
      whitespace
      token
      comment
White space
whitespace:
      Any character with Unicode class Zs
      Horizontal tab character (U+0009)
      Vertical tab character (U+000B)
      Form feed character (U+000C)
      Carriage return character (U+000D) followed by line feed character (U+000A)
      new-line-character
new-line-character:
      Carriage return character (U+000D)
      Line feed character (U+000A)
      Next line character (U+0085)
      Line separator character (U+2028)
      Paragraph separator character (U+2029)
Comment
comment:
      single-line-comment
      delimited-comment
single-line-comment:
      //  single-line-comment-charactersopt
single-line-comment-characters:
      single-line-comment-character  single-line-comment-charactersopt
single-line-comment-character:
      Any Unicode character except a new-line-character
delimited-comment:
      /* delimited-comment-textopt  asterisks  /
delimited-comment-text:
      delimited-comment-section delimited-comment-textopt
delimited-comment-section:
      /
      asterisksopt  not-slash-or-asterisk
asterisks: 
      * asterisksopt
not-slash-or-asterisk:
      Any Unicode character except * or /
Tokens
token:
      identifier
      keyword
      literal
      operator-or-punctuator
Character escape sequences
character-escape-sequence:
      #(  escape-sequence-list  )
escape-sequence-list:
      single-escape-sequence
      escape-sequence-list  ,  single-escape-sequence
single-escape-sequence:
      long-unicode-escape-sequence
      short-unicode-escape-sequence
      control-character-escape-sequence
      escape-escape
long-unicode-escape-sequence:
      hex-digit  hex-digit  hex-digit  hex-digit  hex-digit  hex-digit  hex-digit  hex-digit
short-unicode-escape-sequence:
      hex-digit  hex-digit  hex-digit  hex-digit
control-character-escape-sequence:
      control-character
control-character:
      cr
      lf
      tab
escape-escape:
      #
Literals
literal:
      logical-literal
      number-literal
      text-literal
      null-literal
      verbatim-literal
logical-literal:
      true
      false
number-literal:
      decimal-number-literal
      hexadecimal-number-literal
decimal-digits:
      decimal-digit decimal-digitsopt
decimal-digit:  one of
      0  1  2  3  4  5  6  7  8  9
hexadecimal-number-literal:
      0x  hex-digits
      0X  hex-digits
hex-digits:
      hex-digit hex-digitsopt
hex-digit:  one of
      0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  a  b  c  d e  f
decimal-number-literal:
      decimal-digits  .  decimal-digits  exponent-partopt
      .  decimal-digits  exponent-partopt
      decimal-digits  exponent-partopt
exponent-part:
      e  signopt  decimal-digits
      E  signopt  decimal-digits sign:  one of
      +  -
text-literal:
      ""  text-literal-charactersopt  ""
text-literal-characters:
      text-literal-character  text-literal-charactersopt
text-literal-character:
      single-text-character
      character-escape-sequence
      double-quote-escape-sequence
single-text-character:
      Any character except "" (U+0022) or # (U+0023) followed by ( (U+0028)
double-quote-escape-sequence:
      """" (U+0022, U+0022)
null-literal:
      null
verbatim-literal:
      #!"" text-literal-charactersopt ""
Identifiers
identifier:
      regular-identifier
      quoted-identifier
regular-identifier:
      available-identifier
      available-identifier  dot-character  regular-identifier
available-identifier:
      A keyword-or-identifier that is not a keyword
keyword-or-identifier:
      letter-character
      underscore-character
      identifier-start-character
identifier-part-characters
identifier-start-character:
      letter-character
      underscore-character
identifier-part-characters:
      identifier-part-character  identifier-part-charactersopt
identifier-part-character:
      letter-character
      decimal-digit-character
      underscore-character
      connecting-character
      combining-character
      formatting-character
generalized-identifier:
      generalized-identifier-part
      generalized-identifier separated only by blanks (U+0020) generalized-identifier-part
generalized-identifier-part:
      generalized-identifier-segment
      decimal-digit-character generalized-identifier-segment
generalized-identifier-segment:
      keyword-or-identifier
      keyword-or-identifier dot-character  keyword-or-identifier
dot-character:
      .  (U+002E)
underscore-character:
      _  (U+005F)
letter-character:_
      A Unicode character of classes Lu, Ll, Lt, Lm, Lo, or Nl
combining-character:
      A Unicode character of classes Mn or Mc
decimal-digit-character:
      A Unicode character of the class Nd
connecting-character:
      A Unicode character of the class Pc
formatting-character:
      A Unicode character of the class Cf
quoted-identifier:
      #""  text-literal-charactersopt  ""
Keywords and predefined identifiers
Predefined identifiers and keywords cannot be redefined. A quoted identifier can be used to handle identifiers that would otherwise collide with predefined identifiers or keywords.
keyword:  one of
      and as each else error false if in is let meta not null or otherwise
      section shared then true try type #binary #date #datetime
      #datetimezone #duration #infinity #nan #sections #shared #table #time
Operators and punctuators
operator-or-punctuator:  one of
      , ; = < <= > >= <> + - * / & ( ) [ ] { } @ ? ?? => .. ...
Syntactic grammar
Documents
document:
      section-document
      expression-document
Section Documents
section-document:
      section
section:
      literal-attributesopt  section  section-name  ;  section-membersopt
section-name:
      identifier
section-members:
      section-member section-membersopt
section-member:
      literal-attributesopt  sharedopt  section-member-name  =  expression  ;
section-member-name:
      identifier
Expression Documents
Expressions
expression-document:
      expression
expression:
      logical-or-expression
      each-expression
      function-expression
      let-expression
      if-expression
      error-raising-expression
      error-handling-expression
Logical expressions
logical-or-expression:
      logical-and-expression
      logical-and-expression  or  logical-or-expression
logical-and-expression:
      is-expression
      logical-and-expression  and  is-expression
Is expression
is-expression:
      as-expression
      is-expression is  nullable-primitive-type
nullable-primitive-type:
      nullableopt  primitive-type
As expression
as-expression:
      equality-expression
      as-expression  as  nullable-primitive-type
Equality expression
equality-expression:
      relational-expression
      relational-expression  =  equality-expression
      relational-expression  <>  equality-expression
Relational expression
relational-expression:
      additive-expression
      additive-expression  <  relational-expression
      additive-expression  >  relational-expression
      additive-expression  <=  relational-expression
      additive-expression  >=  relational-expression
Arithmetic expressions
additive-expression:
      multiplicative-expression
      multiplicative-expression  +  additive-expression
      multiplicative-expression  -  additive-expression
      multiplicative-expression  &  _additive-expression
multiplicative-expression:
      metadata-expression
      metadata-expression  *  multiplicative-expression
      metadata-expression  /  multiplicative-expression
Metadata expression
metadata-expression:
      unary-expression
      unary-expression  meta  unary-expression
Unary expression
unary-expression:
      type-expression
      +  unary-expression
      -  unary-expression
      not  unary-expression
Primary expression
primary-expression:
      literal-expression
      list-expression
      record-expression
      identifier-expression
      section-access-expression
      parenthesized-expression
      field-access-expression
      item-access-expression
      invoke-expression
      not-implemented-expression
Literal expression
literal-expression:
      literal
Identifier expression
identifier-expression:
      identifier-reference
identifier-reference:
      exclusive-identifier-reference
      inclusive-identifier-reference
exclusive-identifier-reference:
      identifier
inclusive-identifier-reference:
      @  identifier
Section-access expression
section-access-expression:
      identifier ! identifier
Parenthesized expression
parenthesized-expression:
      (  expression  )
Not-implemented expression
not-implemented-expression:
      ...
Invoke expression
invoke-expression:
      primary-expression  (  argument-listopt  )
argument-list:
      expression
      expression  ,   argument-list
List expression
list-expression:
      {  item-listopt  }
item-list:
      item
      item  ,  item-list
item:
      expression
      expression  ..  expression
Record expression
record-expression:
      [  field-listopt  ]
field-list:
      field
      field  ,  field-list
field:
      field-name  =  expression
field-name:
      generalized-identifier
      quoted-identifier
Item access expression
item-access-expression:
      item-selection
      optional-item-selection
item-selection:
      primary-expression  {  item-selector  }
optional-item-selection:
      primary-expression  {  item-selector  } ?
item-selector:
      expression
Field access expressions
field-access-expression:
      field-selection
      implicit-target-field-selection
      projection
      implicit-target-projection
field-selection:
      primary-expression  field-selector
field-selector:
      required-field-selector
      optional-field-selector
required-field-selector:
      [   field-name  ]
optional-field-selector:
      [   field-name  ] ?
implicit-target-field-selection:
      field-selector
projection:
      primary-expression  required-projection
      primary-expression  optional-projection
required-projection:_
      [ required-selector-list ]
optional-projection:
      [ required-selector-list ] ?
required-selector-list:
      required-field-selector
      required-field-selector ,  required-selector-list
implicit-target-projection:
      required-projection
      optional-projection
Function expression
function-expression:
      (  parameter-listopt  )  return-typeopt  =>  function-body
function-body:
      expression
parameter-list:
      fixed-parameter-list
      fixed-parameter-list  ,  optional-parameter-list
      optional-parameter-list
fixed-parameter-list:
      parameter
      parameter  ,  fixed-parameter-list
parameter:
      parameter-name  primitive-parameter-typeopt
parameter-name:
      identifier
primitive-parameter-type:
      primitive-assertion
return-type:
      primitive-assertion
primitive-assertion:
      as  nullable-primitive-type
optional-parameter-list:
      optional-parameter
      optional-parameter  ,  optional-parameter-list
optional-parameter:
      optional  parameter
Each expression
each-expression:
      each each-expression-body
each-expression-body:
      function-body
Let expression
let-expression:
      let  variable-list  in  expression
variable-list:
      variable
      variable  ,  variable-list
variable:
      variable-name  =  expression
variable-name:
      identifier
If expression
if-expression:
      if if-condition  then  true-expression  else  false-expression
if-condition:
      expression
true-expression:
      expression
false-expression:
      expression
Type expression
type-expression:
      primary-expression
      type  primary-type
type:
      primary-expression
      primary-type
primary-type:
      primitive-type
      record-type
      list-type
      function-type
      table-type
      nullable-type
primitive-type: one of
      any anynonnull binary date datetime datetimezone duration function
      list logical none null number record table text time type
record-type:
      [  open-record-marker  ]
      [   field-specification-listopt  ]
      [   field-specification-list  ,  open-record-marker  ] 
field-specification-list:
      field-specification
      field-specification
,  field-specification-list
field-specification:
      optionalopt field-name field-type-specificationopt
field-type-specification:
      = field-type
field-type:
      type
open-record-marker:
      ...
list-type:
      {   item-type   }
item-type:
      type
function-type:
      function (  parameter-specification-listopt  )  return-type
parameter-specification-list:
      required-parameter-specification-list
      required-parameter-specification-list  ,  optional-parameter-specification-list
      optional-parameter-specification-list
required-parameter-specification-list:
      required-parameter-specification
      required-parameter-specification  ,  required-parameter-specification-list
required-parameter-specification:
      parameter-specification
optional-parameter-specification-list:
      optional-parameter-specification
      optional-parameter-specification  ,  optional-parameter-specification-list
optional-parameter-specification:
      optional parameter-specification
parameter-specification:
      parameter-name  parameter-type
parameter-type:
      assertion
assertion:
      as type
table-type:
      table  row-type
row-type:
      [   field-specification-listopt  ]
nullable-type:
      nullable  type
Error raising expression
error-raising-expression:
      error  expression_
Error handling expression
error-handling-expression:
      try protected-expression
error-handleropt
protected-expression:
      expression
error-handler:
      otherwise-clause
      catch-clause
otherwise-clause:
      otherwise default-expression
default-expression:
      expression
catch-clause:
      catch catch-function
catch-function:
      (parameter-nameopt) => function-body
Literal Attributes
literal-attributes:
      record-literal
record-literal:
      [ literal-field-listopt ]
literal-field-list:
      literal-field
      literal-field , literal-field-list
literal-field:
      field-name = any-literal
list-literal:
      { literal-item-listopt }
literal-item-list:
      any-literal
      any-literal , literal-item-list
any-literal:
      record-literal
      list-literal
      logical-literal
      number-literal
      text-literal
      null-literal"
